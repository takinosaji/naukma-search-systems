This work is licensed under the Creative Commons AttributionNonCommercial-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter
to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.Preface by Scott Chacon
Welcome to the second edition of Pro Git. The first edition was published over
four years ago now. Since then a lot has changed and yet many important
things have not. While most of the core commands and concepts are still valid
today as the Git core team is pretty fantastic at keeping things backward compatible, there have been some significant additions and changes in the community surrounding Git. The second edition of this book is meant to address those
changes and update the book so it can be more helpful to the new user.
When I wrote the first edition, Git was still a relatively difficult to use and
barely adopted tool for the harder core hacker. It was starting to gain steam in
certain communities, but had not reached anywhere near the ubiquity it has today. Since then, nearly every open source community has adopted it. Git has
made incredible progress on Windows, in the explosion of graphical user interfaces to it for all platforms, in IDE support and in business use. The Pro Git of
four years ago knows about none of that. One of the main aims of this new edition is to touch on all of those new frontiers in the Git community.
The Open Source community using Git has also exploded. When I originally
sat down to write the book nearly five years ago (it took me a while to get the
first version out), I had just started working at a very little known company developing a Git hosting website called GitHub. At the time of publishing there
were maybe a few thousand people using the site and just four of us working on
it. As I write this introduction, GitHub is announcing our 10 millionth hosted
project, with nearly 5 million registered developer accounts and over 230 employees. Love it or hate it, GitHub has heavily changed large swaths of the Open
Source community in a way that was barely conceivable when I sat down to
write the first edition.
I wrote a small section in the original version of Pro Git about GitHub as an
example of hosted Git which I was never very comfortable with. I didn’t much
like that I was writing what I felt was essentially a community resource and also
talking about my company in it. While I still don’t love that conflict of interests,
the importance of GitHub in the Git community is unavoidable. Instead of an
example of Git hosting, I have decided to turn that part of the book into more
deeply describing what GitHub is and how to effectively use it. If you are going
to learn how to use Git then knowing how to use GitHub will help you take part
iiiin a huge community, which is valuable no matter which Git host you decide to
use for your own code.
The other large change in the time since the last publishing has been the development and rise of the HTTP protocol for Git network transactions. Most of
the examples in the book have been changed to HTTP from SSH because it’s so
much simpler.
It’s been amazing to watch Git grow over the past few years from a relatively
obscure version control system to basically dominating commercial and open
source version control. I’m happy that Pro Git has done so well and has also
been able to be one of the few technical books on the market that is both quite
successful and fully open source.
I hope you enjoy this updated edition of Pro Git.
iv
Preface by Scott ChaconPreface by Ben Straub
The first edition of this book is what got me hooked on Git. This was my introduction to a style of making software that felt more natural than anything I had
seen before. I had been a developer for several years by then, but this was the
right turn that sent me down a much more interesting path than the one I was
on.
Now, years later, I’m a contributor to a major Git implementation, I’ve
worked for the largest Git hosting company, and I’ve traveled the world teaching people about Git. When Scott asked if I’d be interested in working on the
second edition, I didn’t even have to think.
It’s been a great pleasure and privilege to work on this book. I hope it helps
you as much as it did me.
vDedications
To my wife, Becky, without whom this adventure never would have begun. — Ben
This edition is dedicated to my girls. To my wife Jessica who has supported me
for all of these years and to my daughter Josephine, who will support me when
I’m too old to know what’s going on. — Scott
viiContributors
Since this is an Open Source book, we have gotten several errata and content
changes donated over the years. Here are all the people who have contributed
to the English version of Pro Git as an open source project. Thank you everyone
for helping make this a better book for everyone.
2 Aaron Schumacher
4 Aggelos Orfanakos
4 Alec Clews
1 Alex Moundalexis
2 Alexander Harkness
1 Alexander Kahn
1 Andrew McCarthy
1 AntonioK
1 Benjamin Bergman
1 Brennon Bortz
2 Brian P O'Rourke
1 Bryan Goines
1 Cameron Wright
1 Chris Down
1 Christian Kluge
1 Christoph Korn
2 Ciro Santilli
2 Cor
1 Dan Croak
1 Dan Johnson
1 Daniel Kay
2 Daniel Rosen
1 DanielWeber
1 Dave Dash
10 Davide Fiorentino lo Regio
2 Dilip M
1 Dimitar Bonev
1 Emmanuel Trillaud
1 Eric-Paul Lecluse
1 Eugene Serkin
1 Fernando Dobladez
2 Gordon McCreight
1 Helmut K. C. Tessarek
ix31 Igor Murzov
1 Ilya Kuznetsov
1 Jason St. John
1 Jay Taggart
1 Jean Jordaan
51 Jean-Noël Avila
1 Jean-Noël Rouvignac
1 Jed Hartman
1 Jeffrey Forman
1 John DeStefano
1 Junior
1 Kieran Spear
1 Larry Shatzer, Jr
1 Linquize
1 Markus
7 Matt Deacalion Stevens
1 Matthew McCullough
1 Matthieu Moy
1 Max F. Albrecht
1 Michael Schneider
8 Mike D. Smith
1 Mike Limansky
1 Olivier Trichet
1 Ondrej Novy
6 Ori Avtalion
1 Paul Baumgart
1 Peter Vojtek
1 Philipp Kempgen
2 Philippe Lhoste
1 PowerKiKi
1 Radek Simko
1 Rasmus Abrahamsen
1 Reinhard Holler
1 Ross Light
1 Ryuichi Okumura
1 Sebastian Wiesinger
1 Severyn Kozak
1 Shane
2 Shannen
8 Sitaram Chamarty
5 Soon Van
4 Sven Axelsson
2 Tim Court
1 Tuomas Suutari
1 Vlad Gorodetsky
3 W. Trevor King
1 Wyatt Carss
1 Włodzimierz Gajda
1 Xue Fuqiao
1 Yue Lin Ho
x
Contributors2 adelcambre
1 anaran
1 bdukes
1 burningTyger
1 cor
1 iosias
7 nicesw123
1 onovy
2 pcasaretto
1 sampablokuper
xi
ContributorsIntroduction
You’re about to spend several hours of your life reading about Git. Let’s take a
minute to explain what we have in store for you. Here is a quick summary of the
ten chapters and three appendices of this book.
In Chapter 1, we’re going to cover Version Control Systems (VCSs) and Git
basics—no technical stuff, just what Git is, why it came about in a land full of
VCSs, what sets it apart, and why so many people are using it. Then, we’ll explain how to download Git and set it up for the first time if you don’t already
have it on your system.
In Chapter 2, we will go over basic Git usage—how to use Git in the 80% of
cases you’ll encounter most often. After reading this chapter, you should be
able to clone a repository, see what has happened in the history of the project,
modify files, and contribute changes. If the book spontaneously combusts at
this point, you should already be pretty useful wielding Git in the time it takes
you to go pick up another copy.
Chapter 3 is about the branching model in Git, often described as Git’s killer
feature. Here you’ll learn what truly sets Git apart from the pack. When you’re
done, you may feel the need to spend a quiet moment pondering how you lived
before Git branching was part of your life.
Chapter 4 will cover Git on the server. This chapter is for those of you who
want to set up Git inside your organization or on your own personal server for
collaboration. We will also explore various hosted options if you prefer to let
someone else handle that for you.
Chapter 5 will go over in full detail various distributed workflows and how to
accomplish them with Git. When you are done with this chapter, you should be
able to work expertly with multiple remote repositories, use Git over email and
deftly juggle numerous remote branches and contributed patches.
Chapter 6 covers the GitHub hosting service and tooling in depth. We cover
signing up for and managing an account, creating and using Git repositories,
common workflows to contribute to projects and to accept contributions to
yours, GitHub’s programmatic interface and lots of little tips to make your life
easier in general.
Chapter 7 is about advanced Git commands. Here you will learn about topics like mastering the scary reset command, using binary search to identify
xiiibugs, editing history, revision selection in detail, and a lot more. This chapter
will round out your knowledge of Git so that you are truly a master.
Chapter 8 is about configuring your custom Git environment. This includes
setting up hook scripts to enforce or encourage customized policies and using
environment configuration settings so you can work the way you want to. We
will also cover building your own set of scripts to enforce a custom committing
policy.
Chapter 9 deals with Git and other VCSs. This includes using Git in a Subversion (SVN) world and converting projects from other VCSs to Git. A lot of organizations still use SVN and are not about to change, but by this point you’ll have
learned the incredible power of Git—and this chapter shows you how to cope if
you still have to use a SVN server. We also cover how to import projects from
several different systems in case you do convince everyone to make the plunge.
Chapter 10 delves into the murky yet beautiful depths of Git internals. Now
that you know all about Git and can wield it with power and grace, you can
move on to discuss how Git stores its objects, what the object model is, details
of packfiles, server protocols, and more. Throughout the book, we will refer to
sections of this chapter in case you feel like diving deep at that point; but if you
are like us and want to dive into the technical details, you may want to read
Chapter 10 first. We leave that up to you.
In Appendix A we look at a number of examples of using Git in various specific environments. We cover a number of different GUIs and IDE programming
environments that you may want to use Git in and what is available for you. If
you’re interested in an overview of using Git in your shell, in Visual Studio or
Eclipse, take a look here.
In Appendix B we explore scripting and extending Git through tools like libgit2 and JGit. If you’re interested in writing complex and fast custom tools and
need low level Git access, this is where you can see what that landscape looks
like.
Finally in Appendix C we go through all the major Git commands one at a
time and review where in the book we covered them and what we did with
them. If you want to know where in the book we used any specific Git command
you can look that up here.
Let’s get started.
xiv
IntroductionTable of Contents
Preface by Scott Chacon iii
Preface by Ben Straub v
Dedications vii
Contributors ix
Introduction xiii
CHAPTER 1: Getting Started 27
About Version Control 27
Local Version Control Systems 27
Centralized Version Control Systems 28
Distributed Version Control Systems 29
A Short History of Git 31
Git Basics 31
Snapshots, Not Differences 32
Nearly Every Operation Is Local 33
Git Has Integrity 33
Git Generally Only Adds Data 34
The Three States 34
The Command Line 36
Installing Git 36
Installing on Linux 36
xvInstalling on Mac 37
Installing on Windows 38
Installing from Source 38
First-Time Git Setup 39
Your Identity 40
Your Editor 40
Checking Your Settings 41
Getting Help 42
Summary 42
CHAPTER 2: Git Basics 43
Getting a Git Repository 43
Initializing a Repository in an Existing Directory 43
Cloning an Existing Repository 44
Recording Changes to the Repository 45
Checking the Status of Your Files 46
Tracking New Files 47
Staging Modified Files 47
Short Status 49
Ignoring Files 50
Viewing Your Staged and Unstaged Changes 51
Committing Your Changes 54
Skipping the Staging Area 55
Removing Files 56
Moving Files 58
Viewing the Commit History 58
Limiting Log Output 64
Undoing Things 66
Unstaging a Staged File 66
Unmodifying a Modified File 68
Working with Remotes 69
Table of Contents
xviShowing Your Remotes 69
Adding Remote Repositories 70
Fetching and Pulling from Your Remotes 71
Pushing to Your Remotes 72
Inspecting a Remote 72
Removing and Renaming Remotes 73
Tagging 74
Listing Your Tags 74
Creating Tags 75
Annotated Tags 75
Lightweight Tags 76
Tagging Later 76
Sharing Tags 77
Checking out Tags 78
Git Aliases 78
Summary 80
CHAPTER 3: Git Branching 81
Branches in a Nutshell 81
Creating a New Branch 84
Switching Branches 85
Basic Branching and Merging 89
Basic Branching 89
Basic Merging 94
Basic Merge Conflicts 96
Branch Management 99
Branching Workflows 100
Long-Running Branches 100
Topic Branches 101
Remote Branches 103
Pushing 109
Table of Contents
xviiTracking Branches 111
Pulling 113
Deleting Remote Branches 113
Rebasing 114
The Basic Rebase 114
More Interesting Rebases 116
The Perils of Rebasing 119
Rebase When You Rebase 122
Rebase vs. Merge 124
Summary 124
CHAPTER 4: Git on the Server 125
The Protocols 126
Local Protocol 126
The HTTP Protocols 127
The SSH Protocol 130
The Git Protocol 130
Getting Git on a Server 131
Putting the Bare Repository on a Server 132
Small Setups 133
Generating Your SSH Public Key 134
Setting Up the Server 135
Git Daemon 138
Smart HTTP 139
GitWeb 141
GitLab 144
Installation 144
Administration 145
Basic Usage 148
Working Together 148
Third Party Hosted Options 149
Table of Contents
xviiiSummary 149
CHAPTER 5: Distributed Git 151
Distributed Workflows 151
Centralized Workflow 151
Integration-Manager Workflow 152
Dictator and Lieutenants Workflow 153
Workflows Summary 154
Contributing to a Project 155
Commit Guidelines 155
Private Small Team 157
Private Managed Team 164
Forked Public Project 170
Public Project over Email 174
Summary 178
Maintaining a Project 178
Working in Topic Branches 178
Applying Patches from Email 179
Checking Out Remote Branches 182
Determining What Is Introduced 183
Integrating Contributed Work 185
Tagging Your Releases 191
Generating a Build Number 192
Preparing a Release 193
The Shortlog 193
Summary 194
CHAPTER 6: GitHub 195
Account Setup and Configuration 195
SSH Access 196
Your Avatar 198
Table of Contents
xixYour Email Addresses 199
Two Factor Authentication 200
Contributing to a Project 201
Forking Projects 201
The GitHub Flow 202
Advanced Pull Requests 210
Markdown 215
Maintaining a Project 220
Creating a New Repository 220
Adding Collaborators 222
Managing Pull Requests 224
Mentions and Notifications 229
Special Files 233
README 233
CONTRIBUTING 234
Project Administration 234
Managing an organization 236
Organization Basics 236
Teams 237
Audit Log 239
Scripting GitHub 240
Hooks 241
The GitHub API 245
Basic Usage 246
Commenting on an Issue 247
Changing the Status of a Pull Request 248
Octokit 250
Summary 251
CHAPTER 7: Git Tools 253
Revision Selection 253
Table of Contents
xxSingle Revisions 253
Short SHA-1 253
Branch References 255
RefLog Shortnames 256
Ancestry References 257
Commit Ranges 259
Interactive Staging 262
Staging and Unstaging Files 262
Staging Patches 265
Stashing and Cleaning 266
Stashing Your Work 266
Creative Stashing 269
Creating a Branch from a Stash 270
Cleaning your Working Directory 271
Signing Your Work 273
GPG Introduction 273
Signing Tags 273
Verifying Tags 274
Signing Commits 275
Everyone Must Sign 277
Searching 277
Git Grep 277
Git Log Searching 279
Rewriting History 281
Changing the Last Commit 281
Changing Multiple Commit Messages 282
Reordering Commits 284
Squashing Commits 285
Splitting a Commit 286
The Nuclear Option: filter-branch 287
Reset Demystified 289
Table of Contents
xxiThe Three Trees 289
The Workflow 291
The Role of Reset 297
Reset With a Path 302
Squashing 305
Check It Out 308
Summary 310
Advanced Merging 311
Merge Conflicts 311
Undoing Merges 323
Other Types of Merges 326
Rerere 331
Debugging with Git 337
File Annotation 337
Binary Search 339
Submodules 341
Starting with Submodules 341
Cloning a Project with Submodules 343
Working on a Project with Submodules 345
Submodule Tips 356
Issues with Submodules 358
Bundling 360
Replace 364
Credential Storage 373
Under the Hood 374
A Custom Credential Cache 377
Summary 379
CHAPTER 8: Customizing Git 381
Git Configuration 381
Basic Client Configuration 382
Table of Contents
xxiiColors in Git 385
External Merge and Diff Tools 386
Formatting and Whitespace 390
Server Configuration 392
Git Attributes 393
Binary Files 393
Keyword Expansion 396
Exporting Your Repository 400
Merge Strategies 401
Git Hooks 402
Installing a Hook 402
Client-Side Hooks 403
Server-Side Hooks 405
An Example Git-Enforced Policy 406
Server-Side Hook 406
Client-Side Hooks 412
Summary 416
CHAPTER 9: Git and Other Systems 417
Git as a Client 417
Git and Subversion 417
Git and Mercurial 429
Git and Perforce 438
Git and TFS 454
Migrating to Git 463
Subversion 464
Mercurial 466
Perforce 469
TFS 471
A Custom Importer 472
Table of Contents
xxiiiSummary 480
CHAPTER 10: Git Internals 481
Plumbing and Porcelain 481
Git Objects 482
Tree Objects 485
Commit Objects 488
Object Storage 491
Git References 493
The HEAD 494
Tags 495
Remotes 497
Packfiles 497
The Refspec 501
Pushing Refspecs 503
Deleting References 503
Transfer Protocols 504
The Dumb Protocol 504
The Smart Protocol 506
Protocols Summary 509
Maintenance and Data Recovery 510
Maintenance 510
Data Recovery 511
Removing Objects 513
Environment Variables 517
Global Behavior 518
Repository Locations 518
Pathspecs 519
Committing 519
Networking 520
Diffing and Merging 520
Table of Contents
xxivDebugging 521
Miscellaneous 522
Summary 523
Git in Other Environments 525
Embedding Git in your Applications 541
Git Commands 553
Index 571
Table of Contents
xxvGetting Started
This chapter will be about getting started with Git. We will begin by explaining
some background on version control tools, then move on to how to get Git running on your system and finally how to get it set up to start working with. At the
end of this chapter you should understand why Git is around, why you should
use it and you should be all set up to do so.
About Version Control
What is “version control”, and why should you care? Version control is a system
that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source
code as the files being version controlled, though in reality you can do this with
nearly any type of file on a computer.
If you are a graphic or web designer and want to keep every version of an
image or layout (which you would most certainly want to), a Version Control
System (VCS) is a very wise thing to use. It allows you to revert files back to a
previous state, revert the entire project back to a previous state, compare
changes over time, see who last modified something that might be causing a
problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In
addition, you get all this for very little overhead.
Local Version Control Systems
Many people’s version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they’re clever). This approach is
very common because it is so simple, but it is also incredibly error prone. It is
easy to forget which directory you’re in and accidentally write to the wrong file
or copy over files you don’t mean to.
27
1FIGURE 1-1
Local version
control.
To deal with this issue, programmers long ago developed local VCSs that had
a simple database that kept all the changes to files under revision control.
One of the more popular VCS tools was a system called RCS, which is still
distributed with many computers today. Even the popular Mac OS X operating
system includes the rcs command when you install the Developer Tools. RCS
works by keeping patch sets (that is, the differences between files) in a special
format on disk; it can then re-create what any file looked like at any point in
time by adding up all the patches.
Centralized Version Control Systems
The next major issue that people encounter is that they need to collaborate
with developers on other systems. To deal with this problem, Centralized Version Control Systems (CVCSs) were developed. These systems, such as CVS,
Subversion, and Perforce, have a single server that contains all the versioned
CHAPTER 1: Getting Started
28FIGURE 1-2
Centralized version
control.
files, and a number of clients that check out files from that central place. For
many years, this has been the standard for version control.
This setup offers many advantages, especially over local VCSs. For example,
everyone knows to a certain degree what everyone else on the project is doing.
Administrators have fine-grained control over who can do what; and it’s far easier to administer a CVCS than it is to deal with local databases on every client.
However, this setup also has some serious downsides. The most obvious is
the single point of failure that the centralized server represents. If that server
goes down for an hour, then during that hour nobody can collaborate at all or
save versioned changes to anything they’re working on. If the hard disk the central database is on becomes corrupted, and proper backups haven’t been kept,
you lose absolutely everything – the entire history of the project except whatever single snapshots people happen to have on their local machines. Local VCS
systems suffer from this same problem – whenever you have the entire history
of the project in a single place, you risk losing everything.
Distributed Version Control Systems
This is where Distributed Version Control Systems (DVCSs) step in. In a DVCS
(such as Git, Mercurial, Bazaar or Darcs), clients don’t just check out the latest
About Version Control
29FIGURE 1-3
Distributed version
control.
snapshot of the files: they fully mirror the repository. Thus if any server dies,
and these systems were collaborating via it, any of the client repositories can
be copied back up to the server to restore it. Every clone is really a full backup
of all the data.
Furthermore, many of these systems deal pretty well with having several remote repositories they can work with, so you can collaborate with different
groups of people in different ways simultaneously within the same project. This
CHAPTER 1: Getting Started
30allows you to set up several types of workflows that aren’t possible in centralized systems, such as hierarchical models.
A Short History of Git
As with many great things in life, Git began with a bit of creative destruction
and fiery controversy.
The Linux kernel is an open source software project of fairly large scope. For
most of the lifetime of the Linux kernel maintenance (1991–2002), changes to
the software were passed around as patches and archived files. In 2002, the Linux kernel project began using a proprietary DVCS called BitKeeper.
In 2005, the relationship between the community that developed the Linux
kernel and the commercial company that developed BitKeeper broke down,
and the tool’s free-of-charge status was revoked. This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux) to
develop their own tool based on some of the lessons they learned while using
BitKeeper. Some of the goals of the new system were as follows:
• Speed
• Simple design
• Strong support for non-linear development (thousands of parallel
branches)
• Fully distributed
• Able to handle large projects like the Linux kernel efficiently (speed and
data size)
Since its birth in 2005, Git has evolved and matured to be easy to use and yet
retain these initial qualities. It’s incredibly fast, it’s very efficient with large
projects, and it has an incredible branching system for non-linear development
(See Chapter 3).
Git Basics
So, what is Git in a nutshell? This is an important section to absorb, because if
you understand what Git is and the fundamentals of how it works, then using
Git effectively will probably be much easier for you. As you learn Git, try to clear
your mind of the things you may know about other VCSs, such as Subversion
and Perforce; doing so will help you avoid subtle confusion when using the tool.
Git stores and thinks about information much differently than these other systems, even though the user interface is fairly similar, and understanding those
differences will help prevent you from becoming confused while using it.
A Short History of Git
31FIGURE 1-4
Storing data as
changes to a base
version of each file.
FIGURE 1-5
Storing data as
snapshots of the
project over time.
Snapshots, Not Differences
The major difference between Git and any other VCS (Subversion and friends
included) is the way Git thinks about its data. Conceptually, most other systems
store information as a list of file-based changes. These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a set of
files and the changes made to each file over time.
Git doesn’t think of or store its data this way. Instead, Git thinks of its data
more like a set of snapshots of a miniature filesystem. Every time you commit,
or save the state of your project in Git, it basically takes a picture of what all
your files look like at that moment and stores a reference to that snapshot. To
be efficient, if files have not changed, Git doesn’t store the file again, just a link
to the previous identical file it has already stored. Git thinks about its data more
like a stream of snapshots.
CHAPTER 1: Getting Started
32This is an important distinction between Git and nearly all other VCSs. It
makes Git reconsider almost every aspect of version control that most other
systems copied from the previous generation. This makes Git more like a mini
filesystem with some incredibly powerful tools built on top of it, rather than
simply a VCS. We’ll explore some of the benefits you gain by thinking of your
data this way when we cover Git branching in Chapter 3.
Nearly Every Operation Is Local
Most operations in Git only need local files and resources to operate – generally
no information is needed from another computer on your network. If you’re
used to a CVCS where most operations have that network latency overhead,
this aspect of Git will make you think that the gods of speed have blessed Git
with unworldly powers. Because you have the entire history of the project right
there on your local disk, most operations seem almost instantaneous.
For example, to browse the history of the project, Git doesn’t need to go out
to the server to get the history and display it for you – it simply reads it directly
from your local database. This means you see the project history almost instantly. If you want to see the changes introduced between the current version
of a file and the file a month ago, Git can look up the file a month ago and do a
local difference calculation, instead of having to either ask a remote server to
do it or pull an older version of the file from the remote server to do it locally.
This also means that there is very little you can’t do if you’re offline or off
VPN. If you get on an airplane or a train and want to do a little work, you can
commit happily until you get to a network connection to upload. If you go home
and can’t get your VPN client working properly, you can still work. In many other systems, doing so is either impossible or painful. In Perforce, for example,
you can’t do much when you aren’t connected to the server; and in Subversion
and CVS, you can edit files, but you can’t commit changes to your database (because your database is offline). This may not seem like a huge deal, but you
may be surprised what a big difference it can make.
Git Has Integrity
Everything in Git is check-summed before it is stored and is then referred to by
that checksum. This means it’s impossible to change the contents of any file or
directory without Git knowing about it. This functionality is built into Git at the
lowest levels and is integral to its philosophy. You can’t lose information in
transit or get file corruption without Git being able to detect it.
The mechanism that Git uses for this checksumming is called a SHA-1 hash.
This is a 40-character string composed of hexadecimal characters (0–9 and a–f)
Git Basics
33and calculated based on the contents of a file or directory structure in Git. A
SHA-1 hash looks something like this:
24b9da6552252987aa493b52f8696cd6d3b00373
You will see these hash values all over the place in Git because it uses them
so much. In fact, Git stores everything in its database not by file name but by
the hash value of its contents.
Git Generally Only Adds Data
When you do actions in Git, nearly all of them only add data to the Git database.
It is hard to get the system to do anything that is not undoable or to make it
erase data in any way. As in any VCS, you can lose or mess up changes you haven’t committed yet; but after you commit a snapshot into Git, it is very difficult
to lose, especially if you regularly push your database to another repository.
This makes using Git a joy because we know we can experiment without the
danger of severely screwing things up. For a more in-depth look at how Git
stores its data and how you can recover data that seems lost, see “Undoing
Things”.
The Three States
Now, pay attention. This is the main thing to remember about Git if you want
the rest of your learning process to go smoothly. Git has three main states that
your files can reside in: committed, modified, and staged. Committed means
that the data is safely stored in your local database. Modified means that you
have changed the file but have not committed it to your database yet. Staged
means that you have marked a modified file in its current version to go into
your next commit snapshot.
This leads us to the three main sections of a Git project: the Git directory, the
working directory, and the staging area.
CHAPTER 1: Getting Started
34FIGURE 1-6
Working directory,
staging area, and Git
directory.
The Git directory is where Git stores the metadata and object database for
your project. This is the most important part of Git, and it is what is copied
when you clone a repository from another computer.
The working directory is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and
placed on disk for you to use or modify.
The staging area is a file, generally contained in your Git directory, that
stores information about what will go into your next commit. It’s sometimes referred to as the “index”, but it’s also common to refer to it as the staging area.
The basic Git workflow goes something like this:
1. You modify files in your working directory.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and
stores that snapshot permanently to your Git directory.
If a particular version of a file is in the Git directory, it’s considered committed. If it has been modified and was added to the staging area, it is staged. And
if it was changed since it was checked out but has not been staged, it is modified. In Chapter 2, you’ll learn more about these states and how you can either
take advantage of them or skip the staged part entirely.
Git Basics
35The Command Line
There are a lot of different ways to use Git. There are the original command line
tools, and there are many graphical user interfaces of varying capabilities. For
this book, we will be using Git on the command line. For one, the command line
is the only place you can run all Git commands – most of the GUIs only implement some subset of Git functionality for simplicity. If you know how to run the
command line version, you can probably also figure out how to run the GUI version, while the opposite is not necessarily true. Also, while your choice of graphical client is a matter of personal taste, all users will have the command-line
tools installed and available.
So we will expect you to know how to open Terminal in Mac or Command
Prompt or Powershell in Windows. If you don’t know what we’re talking about
here, you may need to stop and research that quickly so that you can follow the
rest of the examples and descriptions in this book.
Installing Git
Before you start using Git, you have to make it available on your computer.
Even if it’s already installed, it’s probably a good idea to update to the latest
version. You can either install it as a package or via another installer, or download the source code and compile it yourself.
This book was written using Git version 2.0.0. Though most of the commands we use should work even in ancient versions of Git, some of them
might not or might act slightly differently if you’re using an older version. Since Git is quite excellent at preserving backwards compatibility,
any version after 2.0 should work just fine.
Installing on Linux
If you want to install the basic Git tools on Linux via a binary installer, you can
generally do so through the basic package-management tool that comes with
your distribution. If you’re on Fedora for example, you can use yum:
$ sudo yum install git-all
If you’re on a Debian-based distribution like Ubuntu, try apt-get:
CHAPTER 1: Getting Started
36FIGURE 1-7
Git OS X Installer.
$ sudo apt-get install git-all
For more options, there are instructions for installing on several different
Unix flavors on the Git website, at http://git-scm.com/download/linux.
Installing on Mac
There are several ways to install Git on a Mac. The easiest is probably to install
the Xcode Command Line Tools. On Mavericks (10.9) or above you can do this
simply by trying to run git from the Terminal the very first time. If you don’t
have it installed already, it will prompt you to install it.
If you want a more up to date version, you can also install it via a binary installer. An OSX Git installer is maintained and available for download at the Git
website, at http://git-scm.com/download/mac.
You can also install it as part of the GitHub for Mac install. Their GUI Git tool
has an option to install command line tools as well. You can download that tool
from the GitHub for Mac website, at http://mac.github.com.
Installing Git
37Installing on Windows
There are also a few ways to install Git on Windows. The most official build is
available for download on the Git website. Just go to http://git-scm.com/download/win and the download will start automatically. Note that this is a project
called Git for Windows, which is separate from Git itself; for more information
on it, go to https://git-for-windows.github.io/.
Another easy way to get Git installed is by installing GitHub for Windows. The
installer includes a command line version of Git as well as the GUI. It also works
well with Powershell, and sets up solid credential caching and sane CRLF settings. We’ll learn more about those things a little later, but suffice it to say
they’re things you want. You can download this from the GitHub for Windows
website, at http://windows.github.com.
Installing from Source
Some people may instead find it useful to install Git from source, because you’ll
get the most recent version. The binary installers tend to be a bit behind,
though as Git has matured in recent years, this has made less of a difference.
If you do want to install Git from source, you need to have the following libraries that Git depends on: curl, zlib, openssl, expat, and libiconv. For example, if you’re on a system that has yum (such as Fedora) or apt-get (such as a
Debian based system), you can use one of these commands to install the minimal dependencies for compiling and installing the Git binaries:
$ sudo yum install curl-devel expat-devel gettext-devel \
openssl-devel perl-devel zlib-devel
$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
libz-dev libssl-dev
In order to be able to add the documentation in various formats (doc, html,
info), these additional dependencies are required (Note: users of RHEL and
RHEL-derivatives like CentOS and Scientific Linux will have to enable the EPEL
repository to download the docbook2X package):
$ sudo yum install asciidoc xmlto docbook2X
$ sudo apt-get install asciidoc xmlto docbook2x
Additionally, if you’re using Fedora/RHEL/RHEL-derivatives, you need to do
this
CHAPTER 1: Getting Started
38$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi
due to binary name differences.
When you have all the necessary dependencies, you can go ahead and grab
the latest tagged release tarball from several places. You can get it via the Kernel.org site, at https://www.kernel.org/pub/software/scm/git, or the mirror on
the GitHub web site, at https://github.com/git/git/releases. It’s generally a little clearer what the latest version is on the GitHub page, but the kernel.org page
also has release signatures if you want to verify your download.
Then, compile and install:
$ tar -zxf git-2.0.0.tar.gz
$ cd git-2.0.0
$ make configure
$ ./configure --prefix=/usr
$ make all doc info
$ sudo make install install-doc install-html install-info
After this is done, you can also get Git via Git itself for updates:
$ git clone git://git.kernel.org/pub/scm/git/git.git
First-Time Git Setup
Now that you have Git on your system, you’ll want to do a few things to customize your Git environment. You should have to do these things only once on any
given computer; they’ll stick around between upgrades. You can also change
them at any time by running through the commands again.
Git comes with a tool called git config that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:
1. /etc/gitconfig file: Contains values for every user on the system and
all their repositories. If you pass the option --system to git config, it
reads and writes from this file specifically.
2. ~/.gitconfig or ~/.config/git/config file: Specific to your user.
You can make Git read and write to this file specifically by passing the --
global option.
First-Time Git Setup
393. config file in the Git directory (that is, .git/config) of whatever repository you’re currently using: Specific to that single repository.
Each level overrides values in the previous level, so values in .git/config
trump those in /etc/gitconfig.
On Windows systems, Git looks for the .gitconfig file in the $HOME directory (C:\Users\$USER for most people). It also still looks for /etc/gitconfig,
although it’s relative to the MSys root, which is wherever you decide to install
Git on your Windows system when you run the installer. If you are using version
2.x or later of Git for Windows, there is also a system-level config file at C:
\Documents and Settings\All Users\Application Data\Git\config
on Windows XP, and in C:\ProgramData\Git\config on Windows Vista and
newer. This config file can only be changed by git config -f <file> as an
admin.
Your Identity
The first thing you should do when you install Git is to set your user name and
email address. This is important because every Git commit uses this information, and it’s immutably baked into the commits you start creating:
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
Again, you need to do this only once if you pass the --global option, because then Git will always use that information for anything you do on that system. If you want to override this with a different name or email address for specific projects, you can run the command without the --global option when
you’re in that project.
Many of the GUI tools will help you do this when you first run them.
Your Editor
Now that your identity is set up, you can configure the default text editor that
will be used when Git needs you to type in a message. If not configured, Git uses
your system’s default editor.
If you want to use a different text editor, such as Emacs, you can do the following:
CHAPTER 1: Getting Started
40$ git config --global core.editor emacs
While on a Windows system, if you want to use a different text editor, such as
Notepad++, you can do the following:
On a x86 system
$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -no
On a x64 system
$ git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiIn
Vim, Emacs and Notepad++ are popular text editors often used by developers on Unix based systems like Linux and OS X or a Windows system. If
you are not familiar with either of these editors, you may need to search
for specific instructions for how to set up your favorite editor with Git.
You may find, if you don’t setup an editor like this, you will likely get into
a really confusing state when they are launched. Such example on a Windows system may include a prematurely terminated Git operation during
a Git initiated edit.
Checking Your Settings
If you want to check your settings, you can use the git config --list command to list all the settings Git can find at that point:
$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
You may see keys more than once, because Git reads the same key from different files (/etc/gitconfig and ~/.gitconfig, for example). In this case,
Git uses the last value for each unique key it sees.
First-Time Git Setup
41You can also check what Git thinks a specific key’s value is by typing git
config <key>:
$ git config user.name
John Doe
Getting Help
If you ever need help while using Git, there are three ways to get the manual
page (manpage) help for any of the Git commands:
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
For example, you can get the manpage help for the config command by running
$ git help config
These commands are nice because you can access them anywhere, even offline. If the manpages and this book aren’t enough and you need in-person help,
you can try the #git or #github channel on the Freenode IRC server (irc.freenode.net). These channels are regularly filled with hundreds of people who are
all very knowledgeable about Git and are often willing to help.
Summary
You should have a basic understanding of what Git is and how it’s different from
the centralized version control system you may have previously been using. You
should also now have a working version of Git on your system that’s set up with
your personal identity. It’s now time to learn some Git basics.
CHAPTER 1: Getting Started
42Git Basics
If you can read only one chapter to get going with Git, this is it. This chapter
covers every basic command you need to do the vast majority of the things
you’ll eventually spend your time doing with Git. By the end of the chapter, you
should be able to configure and initialize a repository, begin and stop tracking
files, and stage and commit changes. We’ll also show you how to set up Git to
ignore certain files and file patterns, how to undo mistakes quickly and easily,
how to browse the history of your project and view changes between commits,
and how to push and pull from remote repositories.
Getting a Git Repository
You can get a Git project using two main approaches. The first takes an existing
project or directory and imports it into Git. The second clones an existing Git
repository from another server.
Initializing a Repository in an Existing Directory
If you’re starting to track an existing project in Git, you need to go to the
project’s directory and type:
$ git init
This creates a new subdirectory named .git that contains all of your necessary repository files – a Git repository skeleton. At this point, nothing in your
project is tracked yet. (See Chapter 10 for more information about exactly what
files are contained in the .git directory you just created.)
If you want to start version-controlling existing files (as opposed to an empty
directory), you should probably begin tracking those files and do an initial com-
43
2mit. You can accomplish that with a few git add commands that specify the
files you want to track, followed by a git commit:
$ git add *.c
$ git add LICENSE
$ git commit -m 'initial project version'
We’ll go over what these commands do in just a minute. At this point, you
have a Git repository with tracked files and an initial commit.
Cloning an Existing Repository
If you want to get a copy of an existing Git repository – for example, a project
you’d like to contribute to – the command you need is git clone. If you’re familiar with other VCS systems such as Subversion, you’ll notice that the command is “clone” and not “checkout”. This is an important distinction – instead
of getting just a working copy, Git receives a full copy of nearly all data that the
server has. Every version of every file for the history of the project is pulled
down by default when you run git clone. In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server
back to the state it was in when it was cloned (you may lose some server-side
hooks and such, but all the versioned data would be there – see “Getting Git
on a Server” for more details).
You clone a repository with git clone [url]. For example, if you want to
clone the Git linkable library called libgit2, you can do so like this:
$ git clone https://github.com/libgit2/libgit2
That creates a directory named “libgit2”, initializes a .git directory inside it,
pulls down all the data for that repository, and checks out a working copy of the
latest version. If you go into the new libgit2 directory, you’ll see the project
files in there, ready to be worked on or used. If you want to clone the repository
into a directory named something other than “libgit2”, you can specify that as
the next command-line option:
$ git clone https://github.com/libgit2/libgit2 mylibgit
That command does the same thing as the previous one, but the target directory is called mylibgit.
CHAPTER 2: Git Basics
44FIGURE 2-1
The lifecycle of the
status of your files.
Git has a number of different transfer protocols you can use. The previous
example uses the https:// protocol, but you may also see git:// or
user@server:path/to/repo.git, which uses the SSH transfer protocol.
“Getting Git on a Server” will introduce all of the available options the server
can set up to access your Git repository and the pros and cons of each.
Recording Changes to the Repository
You have a bona fide Git repository and a checkout or working copy of the files
for that project. You need to make some changes and commit snapshots of
those changes into your repository each time the project reaches a state you
want to record.
Remember that each file in your working directory can be in one of two
states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. Untracked files are everything else – any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of
your files will be tracked and unmodified because Git just checked them out
and you haven’t edited anything.
As you edit files, Git sees them as modified, because you’ve changed them
since your last commit. You stage these modified files and then commit all your
staged changes, and the cycle repeats.
Recording Changes to the Repository
45Checking the Status of Your Files
The main tool you use to determine which files are in which state is the git
status command. If you run this command directly after a clone, you should
see something like this:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
This means you have a clean working directory – in other words, there are no
tracked and modified files. Git also doesn’t see any untracked files, or they
would be listed here. Finally, the command tells you which branch you’re on
and informs you that it has not diverged from the same branch on the server.
For now, that branch is always “master”, which is the default; you won’t worry
about it here. Chapter 3 will go over branches and references in detail.
Let’s say you add a new file to your project, a simple README file. If the file
didn’t exist before, and you run git status, you see your untracked file like
so:
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
(use "git add <file>..." to include in what will be committed)
README
nothing added to commit but untracked files present (use "git add" to track)
You can see that your new README file is untracked, because it’s under the
“Untracked files” heading in your status output. Untracked basically means
that Git sees a file you didn’t have in the previous snapshot (commit); Git won’t
start including it in your commit snapshots until you explicitly tell it to do so. It
does this so you don’t accidentally begin including generated binary files or
other files that you did not mean to include. You do want to start including README, so let’s start tracking the file.
CHAPTER 2: Git Basics
46Tracking New Files
In order to begin tracking a new file, you use the command git add. To begin
tracking the README file, you can run this:
$ git add README
If you run your status command again, you can see that your README file is
now tracked and staged to be committed:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
You can tell that it’s staged because it’s under the “Changes to be committed” heading. If you commit at this point, the version of the file at the time you
ran git add is what will be in the historical snapshot. You may recall that when
you ran git init earlier, you then ran git add (files) – that was to begin
tracking files in your directory. The git add command takes a path name for
either a file or a directory; if it’s a directory, the command adds all the files in
that directory recursively.
Staging Modified Files
Let’s change a file that was already tracked. If you change a previously tracked
file called CONTRIBUTING.md and then run your git status command again,
you get something that looks like this:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
Recording Changes to the Repository
47(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
The CONTRIBUTING.md file appears under a section named “Changes not
staged for commit” – which means that a file that is tracked has been modified
in the working directory but not yet staged. To stage it, you run the git add
command. git add is a multipurpose command – you use it to begin tracking
new files, to stage files, and to do other things like marking merge-conflicted
files as resolved. It may be helpful to think of it more as “add this content to the
next commit” rather than “add this file to the project”. Let’s run git add now
to stage the CONTRIBUTING.md file, and then run git status again:
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
modified: CONTRIBUTING.md
Both files are staged and will go into your next commit. At this point, suppose you remember one little change that you want to make in CONTRIBUTING.md before you commit it. You open it again and make that change, and
you’re ready to commit. However, let’s run git status one more time:
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
modified: CONTRIBUTING.md
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
CHAPTER 2: Git Basics
48What the heck? Now CONTRIBUTING.md is listed as both staged and unstaged. How is that possible? It turns out that Git stages a file exactly as it is when
you run the git add command. If you commit now, the version of CONTRIBUTING.md as it was when you last ran the git add command is how it will go
into the commit, not the version of the file as it looks in your working directory
when you run git commit. If you modify a file after you run git add, you have
to run git add again to stage the latest version of the file:
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
new file: README
modified: CONTRIBUTING.md
Short Status
While the git status output is pretty comprehensive, it’s also quite wordy. Git
also has a short status flag so you can see your changes in a more compact way.
If you run git status -s or git status --short you get a far more simplified output from the command:
$ git status -s
M README
MM Rakefile
A lib/git.rb
M lib/simplegit.rb
?? LICENSE.txt
New files that aren’t tracked have a ?? next to them, new files that have
been added to the staging area have an A, modified files have an M and so on.
There are two columns to the output - the left-hand column indicates the status
of the staging area and the right-hand column indicates the status of the working tree. So for example in that output, the README file is modified in the working directory but not yet staged, while the lib/simplegit.rb file is modified
and staged. The Rakefile was modified, staged and then modified again, so
there are changes to it that are both staged and unstaged.
Recording Changes to the Repository
49Ignoring Files
Often, you’ll have a class of files that you don’t want Git to automatically add or
even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases,
you can create a file listing patterns to match them named .gitignore. Here is
an example .gitignore file:
$ cat .gitignore
*.[oa]
*~
The first line tells Git to ignore any files ending in “.o” or “.a” – object and
archive files that may be the product of building your code. The second line
tells Git to ignore all files whose names end with a tilde (~), which is used by
many text editors such as Emacs to mark temporary files. You may also include
a log, tmp, or pid directory; automatically generated documentation; and so
on. Setting up a .gitignore file before you get going is generally a good idea
so you don’t accidentally commit files that you really don’t want in your Git
repository.
The rules for the patterns you can put in the .gitignore file are as follows:
• Blank lines or lines starting with # are ignored.
• Standard glob patterns work.
• You can start patterns with a forward slash (/) to avoid recursivity.
• You can end patterns with a forward slash (/) to specify a directory.
• You can negate a pattern by starting it with an exclamation point (!).
Glob patterns are like simplified regular expressions that shells use. An asterisk (*) matches zero or more characters; [abc] matches any character inside
the brackets (in this case a, b, or c); a question mark (?) matches a single character; and brackets enclosing characters separated by a hyphen ([0-9]) matches any character between them (in this case 0 through 9). You can also use two
asterisks to match nested directories; a/**/z would match a/z, a/b/z,
a/b/c/z, and so on.
Here is another example .gitignore file:
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
CHAPTER 2: Git Basics
50!lib.a
# only ignore the TODO file in the current directory, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
GitHub maintains a fairly comprehensive list of good .gitignore file examples for dozens of projects and languages at https://github.com/github/
gitignore if you want a starting point for your project.
Viewing Your Staged and Unstaged Changes
If the git status command is too vague for you – you want to know exactly
what you changed, not just which files were changed – you can use the git
diff command. We’ll cover git diff in more detail later, but you’ll probably
use it most often to answer these two questions: What have you changed but
not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file
names, git diff shows you the exact lines added and removed – the patch, as
it were.
Let’s say you edit and stage the README file again and then edit the CONTRIBUTING.md file without staging it. If you run your git status command, you
once again see something like this:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
modified: README
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
Recording Changes to the Repository
51modified: CONTRIBUTING.md
To see what you’ve changed but not yet staged, type git diff with no other arguments:
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
Please include a nice description of your changes when you submit your PR;
if we have to read the whole diff to figure out why you're contributing
in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
If you are starting to work on a particular area, feel free to submit a PR
that highlights your work in progress (and note in the PR title that it's
That command compares what is in your working directory with what is in
your staging area. The result tells you the changes you’ve made that you haven’t yet staged.
If you want to see what you’ve staged that will go into your next commit, you
can use git diff --staged. This command compares your staged changes
to your last commit:
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
It’s important to note that git diff by itself doesn’t show all changes
made since your last commit – only changes that are still unstaged. This can be
confusing, because if you’ve staged all of your changes, git diff will give you
no output.
CHAPTER 2: Git Basics
52For another example, if you stage the CONTRIBUTING.md file and then edit
it, you can use git diff to see the changes in the file that are staged and the
changes that are unstaged. If our environment looks like this:
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
modified: CONTRIBUTING.md
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
Now you can use git diff to see what is still unstaged:
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
## Starter Projects
See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
and git diff --cached to see what you’ve staged so far (--staged and
--cached are synonyms):
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
Please include a nice description of your changes when you submit your PR;
if we have to read the whole diff to figure out why you're contributing
Recording Changes to the Repository
53in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
If you are starting to work on a particular area, feel free to submit a PR
that highlights your work in progress (and note in the PR title that it's
GIT DIFF IN AN EXTERNAL TOOL
We will continue to use the git diff command in various ways throughout the rest of the book. There is another way to look at these diffs if you
prefer a graphical or external diff viewing program instead. If you run git
difftool instead of git diff, you can view any of these diffs in software
like emerge, vimdiff and many more (including commercial products).
Run git difftool --tool-help to see what is available on your system.
Committing Your Changes
Now that your staging area is set up the way you want it, you can commit your
changes. Remember that anything that is still unstaged – any files you have created or modified that you haven’t run git add on since you edited them –
won’t go into this commit. They will stay as modified files on your disk. In this
case, let’s say that the last time you ran git status, you saw that everything
was staged, so you’re ready to commit your changes. The simplest way to commit is to type git commit:
$ git commit
Doing so launches your editor of choice. (This is set by your shell’s $EDITOR
environment variable – usually vim or emacs, although you can configure it
with whatever you want using the git config --global core.editor
command as you saw in Chapter 1).
The editor displays the following text (this example is a Vim screen):
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
# new file: README
# modified: CONTRIBUTING.md
CHAPTER 2: Git Basics
54# ~ ~ ~
".git/COMMIT_EDITMSG" 9L, 283C
You can see that the default commit message contains the latest output of
the git status command commented out and one empty line on top. You can
remove these comments and type your commit message, or you can leave
them there to help you remember what you’re committing. (For an even more
explicit reminder of what you’ve modified, you can pass the -v option to git
commit. Doing so also puts the diff of your change in the editor so you can see
exactly what changes you’re committing.) When you exit the editor, Git creates
your commit with that commit message (with the comments and diff stripped
out).
Alternatively, you can type your commit message inline with the commit
command by specifying it after a -m flag, like this:
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
2 files changed, 2 insertions(+)
create mode 100644 README
Now you’ve created your first commit! You can see that the commit has given you some output about itself: which branch you committed to (master),
what SHA-1 checksum the commit has (463dc4f), how many files were
changed, and statistics about lines added and removed in the commit.
Remember that the commit records the snapshot you set up in your staging
area. Anything you didn’t stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you’re
recording a snapshot of your project that you can revert to or compare to later.
Skipping the Staging Area
Although it can be amazingly useful for crafting commits exactly how you want
them, the staging area is sometimes a bit more complex than you need in your
workflow. If you want to skip the staging area, Git provides a simple shortcut.
Adding the -a option to the git commit command makes Git automatically
stage every file that is already tracked before doing the commit, letting you skip
the git add part:
Recording Changes to the Repository
55$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
1 file changed, 5 insertions(+), 0 deletions(-)
Notice how you don’t have to run git add on the CONTRIBUTING.md file in
this case before you commit. That’s because the -a flag includes all changed
files. This is convenient, but be careful; sometimes this flag will cause you to
include unwanted changes.
Removing Files
To remove a file from Git, you have to remove it from your tracked files (more
accurately, remove it from your staging area) and then commit. The git rm
command does that, and also removes the file from your working directory so
you don’t see it as an untracked file the next time around.
If you simply remove the file from your working directory, it shows up under
the “Changed but not updated” (that is, unstaged) area of your git status
output:
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
(use "git add/rm <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
deleted: PROJECTS.md
no changes added to commit (use "git add" and/or "git commit -a")
Then, if you run git rm, it stages the file’s removal:
CHAPTER 2: Git Basics
56$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
deleted: PROJECTS.md
The next time you commit, the file will be gone and no longer tracked. If you
modified the file and added it to the index already, you must force the removal
with the -f option. This is a safety feature to prevent accidental removal of data
that hasn’t yet been recorded in a snapshot and that can’t be recovered from
Git.
Another useful thing you may want to do is to keep the file in your working
tree but remove it from your staging area. In other words, you may want to
keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your .gitignore file and accidentally staged it, like a large log file or a bunch of .a compiled files. To do this,
use the --cached option:
$ git rm --cached README
You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as:
$ git rm log/\*.log
Note the backslash (\) in front of the *. This is necessary because Git does its
own filename expansion in addition to your shell’s filename expansion. This
command removes all files that have the .log extension in the log/ directory.
Or, you can do something like this:
$ git rm \*~
This command removes all files whose names end with a ~.
Recording Changes to the Repository
57Moving Files
Unlike many other VCS systems, Git doesn’t explicitly track file movement. If
you rename a file in Git, no metadata is stored in Git that tells it you renamed
the file. However, Git is pretty smart about figuring that out after the fact – we’ll
deal with detecting file movement a bit later.
Thus it’s a bit confusing that Git has a mv command. If you want to rename a
file in Git, you can run something like:
$ git mv file_from file_to
and it works fine. In fact, if you run something like this and look at the status, you’ll see that Git considers it a renamed file:
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
However, this is equivalent to running something like this:
$ mv README.md README
$ git rm README.md
$ git add README
Git figures out that it’s a rename implicitly, so it doesn’t matter if you rename a file that way or with the mv command. The only real difference is that
mv is one command instead of three – it’s a convenience function. More importantly, you can use any tool you like to rename a file, and address the add/rm
later, before you commit.
Viewing the Commit History
After you have created several commits, or if you have cloned a repository with
an existing commit history, you’ll probably want to look back to see what has
CHAPTER 2: Git Basics
58happened. The most basic and powerful tool to do this is the git log command.
These examples use a very simple project called “simplegit”. To get the
project, run
$ git clone https://github.com/schacon/simplegit-progit
When you run git log in this project, you should get output that looks
something like this:
$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
removed unnecessary test
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
first commit
By default, with no arguments, git log lists the commits made in that
repository in reverse chronological order – that is, the most recent commits
show up first. As you can see, this command lists each commit with its SHA-1
checksum, the author’s name and email, the date written, and the commit message.
A huge number and variety of options to the git log command are available to show you exactly what you’re looking for. Here, we’ll show you some of
the most popular.
One of the more helpful options is -p, which shows the difference introduced in each commit. You can also use -2, which limits the output to only the
last two entries:
Viewing the Commit History
59$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number
diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
spec = Gem::Specification.new do |s|
s.platform = Gem::Platform::RUBY
s.name = "simplegit"
- s.version = "0.1.0"
+ s.version = "0.1.1"
s.author = "Scott Chacon"
s.email = "schacon@gee-mail.com"
s.summary = "A simple gem for using Git in Ruby code."
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
removed unnecessary test
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
end
end
-
-if $0 == __FILE__
- git = SimpleGit.new
- puts git.show
-end
\ No newline at end of file
This option displays the same information but with a diff directly following
each entry. This is very helpful for code review or to quickly browse what happened during a series of commits that a collaborator has added. You can also
use a series of summarizing options with git log. For example, if you want to
see some abbreviated stats for each commit, you can use the --stat option:
CHAPTER 2: Git Basics
60$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number
Rakefile | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
removed unnecessary test
lib/simplegit.rb | 5 -----
1 file changed, 5 deletions(-)
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
first commit
README | 6 ++++++
Rakefile | 23 +++++++++++++++++++++++
lib/simplegit.rb | 25 +++++++++++++++++++++++++
3 files changed, 54 insertions(+)
As you can see, the --stat option prints below each commit entry a list of
modified files, how many files were changed, and how many lines in those files
were added and removed. It also puts a summary of the information at the end.
Another really useful option is --pretty. This option changes the log output to formats other than the default. A few prebuilt options are available for
you to use. The oneline option prints each commit on a single line, which is
useful if you’re looking at a lot of commits. In addition, the short, full, and
fuller options show the output in roughly the same format but with less or
more information, respectively:
$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
Viewing the Commit History
61The most interesting option is format, which allows you to specify your own
log output format. This is especially useful when you’re generating output for
machine parsing – because you specify the format explicitly, you know it won’t
change with updates to Git:
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
Table 2-1 lists some of the more useful options that format takes.
TABLE 2-1. Useful options for git log --pretty=format
Option Description of Output
%H Commit hash
%h Abbreviated commit hash
%T Tree hash
%t Abbreviated tree hash
%P Parent hashes
%p Abbreviated parent hashes
%an Author name
%ae Author email
%ad Author date (format respects the --date=option)
%ar Author date, relative
%cn Committer name
%ce Committer email
%cd Committer date
%cr Committer date, relative
%s Subject
You may be wondering what the difference is between author and committer. The author is the person who originally wrote the work, whereas the committer is the person who last applied the work. So, if you send in a patch to a
CHAPTER 2: Git Basics
62project and one of the core members applies the patch, both of you get credit –
you as the author, and the core member as the committer. We’ll cover this distinction a bit more in Chapter 5.
The oneline and format options are particularly useful with another log
option called --graph. This option adds a nice little ASCII graph showing your
branch and merge history:
$ git log --pretty=format:"%h %s" --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
* 5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
* 11d191e Merge branch 'defunkt' into local
This type of output will become more interesting as we go through branching and merging in the next chapter.
Those are only some simple output-formatting options to git log – there
are many more. Table 2-2 lists the options we’ve covered so far, as well as some
other common formatting options that may be useful, along with how they
change the output of the log command.
TABLE 2-2. Common options to git log
Option Description
-p Show the patch introduced with each commit.
--stat Show statistics for files modified in each commit.
--shortstat Display only the changed/insertions/deletions line from the
--stat command.
--name-only Show the list of files modified after the commit information.
--name-status Show the list of files affected with added/modified/deleted
information as well.
--abbrev-commit Show only the first few characters of the SHA-1 checksum
instead of all 40.
--relative-date Display the date in a relative format (for example, “2 weeks
ago”) instead of using the full date format.
Viewing the Commit History
63Option Description
--graph Display an ASCII graph of the branch and merge history beside the log output.
--pretty
Show commits in an alternate format. Options include oneline, short, full, fuller, and format (where you specify your
own format).
Limiting Log Output
In addition to output-formatting options, git log takes a number of useful
limiting options – that is, options that let you show only a subset of commits.
You’ve seen one such option already – the -2 option, which show only the last
two commits. In fact, you can do -<n>, where n is any integer to show the last n
commits. In reality, you’re unlikely to use that often, because Git by default
pipes all output through a pager so you see only one page of log output at a
time.
However, the time-limiting options such as --since and --until are very
useful. For example, this command gets the list of commits made in the last two
weeks:
$ git log --since=2.weeks
This command works with lots of formats – you can specify a specific date
like "2008-01-15", or a relative date such as "2 years 1 day 3 minutes
ago".
You can also filter the list to commits that match some search criteria. The
--author option allows you to filter on a specific author, and the --grep option lets you search for keywords in the commit messages. (Note that if you
want to specify both author and grep options, you have to add --all-match or
the command will match commits with either.)
Another really helpful filter is the -S option which takes a string and only
shows the commits that introduced a change to the code that added or removed that string. For instance, if you wanted to find the last commit that added or removed a reference to a specific function, you could call:
$ git log -Sfunction_name
CHAPTER 2: Git Basics
64The last really useful option to pass to git log as a filter is a path. If you
specify a directory or file name, you can limit the log output to commits that
introduced a change to those files. This is always the last option and is generally preceded by double dashes (--) to separate the paths from the options.
In Table 2-3 we’ll list these and a few other common options for your reference.
TABLE 2-3. Options to limit the output of git log
Option Description
-(n) Show only the last n commits
--since, --after Limit the commits to those made fied date. after the speci-
--until, --before Limit the commits to those made before the speci- fied date.
--author Only show commits in which the author entry
matches the specified string.
--committer Only show commits in which the committer entry
matches the specified string.
--grep
Only show commits with a commit message containing the string
-S Only show commits adding or removing code
matching the string
For example, if you want to see which commits modifying test files in the Git
source code history are merged and were committed by Junio Hamano in the
month of October 2008, you can run something like this:
$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix "checkout --track -b newbranch" on detached HEAD
b0ad11e - pull: allow "git pull origin $something:$current_branch" into an unborn branch
Of the nearly 40,000 commits in the Git source code history, this command
shows the 6 that match those criteria.
Viewing the Commit History
65Undoing Things
At any stage, you may want to undo something. Here, we’ll review a few basic
tools for undoing changes that you’ve made. Be careful, because you can’t always undo some of these undos. This is one of the few areas in Git where you
may lose some work if you do it wrong.
One of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want
to try that commit again, you can run commit with the --amend option:
$ git commit --amend
This command takes your staging area and uses it for the commit. If you’ve
made no changes since your last commit (for instance, you run this command
immediately after your previous commit), then your snapshot will look exactly
the same, and all you’ll change is your commit message.
The same commit-message editor fires up, but it already contains the message of your previous commit. You can edit the message the same as always,
but it overwrites your previous commit.
As an example, if you commit and then realize you forgot to stage the
changes in a file you wanted to add to this commit, you can do something like
this:
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
You end up with a single commit – the second commit replaces the results of
the first.
Unstaging a Staged File
The next two sections demonstrate how to wrangle your staging area and working directory changes. The nice part is that the command you use to determine
the state of those two areas also reminds you how to undo changes to them.
For example, let’s say you’ve changed two files and want to commit them as
two separate changes, but you accidentally type git add * and stage them
both. How can you unstage one of the two? The git status command reminds you:
CHAPTER 2: Git Basics
66$ git add *
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
modified: CONTRIBUTING.md
Right below the “Changes to be committed” text, it says use git reset
HEAD <file>... to unstage. So, let’s use that advice to unstage the CONTRIBUTING.md file:
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
The command is a bit strange, but it works. The CONTRIBUTING.md file is
modified but once again unstaged.
While git reset can be a dangerous command if you call it with --hard, in
this instance the file in your working directory is not touched. Calling git
reset without an option is not dangerous - it only touches your staging
area.
For now this magic invocation is all you need to know about the git reset
command. We’ll go into much more detail about what reset does and how to
master it to do really interesting things in “Reset Demystified”.
Undoing Things
67Unmodifying a Modified File
What if you realize that you don’t want to keep your changes to the CONTRIBUTING.md file? How can you easily unmodify it – revert it back to what it looked
like when you last committed (or initially cloned, or however you got it into
your working directory)? Luckily, git status tells you how to do that, too. In
the last example output, the unstaged area looks like this:
Changes not staged for commit:
(use "git add <file>..." to update what will be committed)
(use "git checkout -- <file>..." to discard changes in working directory)
modified: CONTRIBUTING.md
It tells you pretty explicitly how to discard the changes you’ve made. Let’s do
what it says:
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
renamed: README.md -> README
You can see that the changes have been reverted.
It’s important to understand that git checkout -- <file> is a dangerous
command. Any changes you made to that file are gone – Git just copied
another file over it. Don’t ever use this command unless you absolutely
know that you don’t want the file.
If you would like to keep the changes you’ve made to that file but still need
to get it out of the way for now, we’ll go over stashing and branching in Chapter 3; these are generally better ways to go.
Remember, anything that is committed in Git can almost always be recovered. Even commits that were on branches that were deleted or commits that
were overwritten with an --amend commit can be recovered (see “Data Recovery” for data recovery). However, anything you lose that was never committed
is likely never to be seen again.
CHAPTER 2: Git Basics
68Working with Remotes
To be able to collaborate on any Git project, you need to know how to manage
your remote repositories. Remote repositories are versions of your project that
are hosted on the Internet or network somewhere. You can have several of
them, each of which generally is either read-only or read/write for you. Collaborating with others involves managing these remote repositories and pushing
and pulling data to and from them when you need to share work. Managing remote repositories includes knowing how to add remote repositories, remove remotes that are no longer valid, manage various remote branches and define
them as being tracked or not, and more. In this section, we’ll cover some of
these remote-management skills.
Showing Your Remotes
To see which remote servers you have configured, you can run the git remote
command. It lists the shortnames of each remote handle you’ve specified. If
you’ve cloned your repository, you should at least see origin – that is the default name Git gives to the server you cloned from:
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
You can also specify -v, which shows you the URLs that Git has stored for the
shortname to be used when reading and writing to that remote:
$ git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
If you have more than one remote, the command lists them all. For example,
a repository with multiple remotes for working with several collaborators might
look something like this.
Working with Remotes
69$ cd grit
$ git remote -v
bakkdoor https://github.com/bakkdoor/grit (fetch)
bakkdoor https://github.com/bakkdoor/grit (push)
cho45 https://github.com/cho45/grit (fetch)
cho45 https://github.com/cho45/grit (push)
defunkt https://github.com/defunkt/grit (fetch)
defunkt https://github.com/defunkt/grit (push)
koke git://github.com/koke/grit.git (fetch)
koke git://github.com/koke/grit.git (push)
origin git@github.com:mojombo/grit.git (fetch)
origin git@github.com:mojombo/grit.git (push)
This means we can pull contributions from any of these users pretty easily.
We may additionally have permission to push to one or more of these, though
we can’t tell that here.
Notice that these remotes use a variety of protocols; we’ll cover more about
this in “Getting Git on a Server”.
Adding Remote Repositories
We’ve mentioned and given some demonstrations of how the clone command
implicitly adds the origin remote for you. Here’s how to add a new remote explicitly. To add a new remote Git repository as a shortname you can reference
easily, run git remote add <shortname> <url>:
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
Now you can use the string pb on the command line in lieu of the whole URL.
For example, if you want to fetch all the information that Paul has but that you
don’t yet have in your repository, you can run git fetch pb:
$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
CHAPTER 2: Git Basics
70Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
* [new branch] master -> pb/master
* [new branch] ticgit -> pb/ticgit
Paul’s master branch is now accessible locally as pb/master – you can
merge it into one of your branches, or you can check out a local branch at that
point if you want to inspect it. (We’ll go over what branches are and how to use
them in much more detail in Chapter 3.)
Fetching and Pulling from Your Remotes
As you just saw, to get data from your remote projects, you can run:
$ git fetch [remote-name]
The command goes out to that remote project and pulls down all the data
from that remote project that you don’t have yet. After you do this, you should
have references to all the branches from that remote, which you can merge in
or inspect at any time.
If you clone a repository, the command automatically adds that remote
repository under the name “origin”. So, git fetch origin fetches any new
work that has been pushed to that server since you cloned (or last fetched
from) it. It’s important to note that the git fetch command only downloads
the data to your local repository – it doesn’t automatically merge it with any of
your work or modify what you’re currently working on. You have to merge it
manually into your work when you’re ready.
If your current branch is set up to track a remote branch (see the next section and Chapter 3 for more information), you can use the git pull command
to automatically fetch and then merge that remote branch into your current
branch. This may be an easier or more comfortable workflow for you; and by
default, the git clone command automatically sets up your local master
branch to track the remote master branch (or whatever the default branch is
called) on the server you cloned from. Running git pull generally fetches data from the server you originally cloned from and automatically tries to merge it
into the code you’re currently working on.
Working with Remotes
71Pushing to Your Remotes
When you have your project at a point that you want to share, you have to push
it upstream. The command for this is simple: git push [remote-name]
[branch-name]. If you want to push your master branch to your origin server
(again, cloning generally sets up both of those names for you automatically),
then you can run this to push any commits you’ve done back up to the server:
$ git push origin master
This command works only if you cloned from a server to which you have
write access and if nobody has pushed in the meantime. If you and someone
else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You’ll have to fetch their work first
and incorporate it into yours before you’ll be allowed to push. See Chapter 3
for more detailed information on how to push to remote servers.
Inspecting a Remote
If you want to see more information about a particular remote, you can use the
git remote show [remote-name] command. If you run this command with
a particular shortname, such as origin, you get something like this:
$ git remote show origin
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured for 'git pull':
master merges with remote master
Local ref configured for 'git push':
master pushes to master (up to date)
It lists the URL for the remote repository as well as the tracking branch information. The command helpfully tells you that if you’re on the master branch
and you run git pull, it will automatically merge in the master branch on the
remote after it fetches all the remote references. It also lists all the remote references it has pulled down.
CHAPTER 2: Git Basics
72That is a simple example you’re likely to encounter. When you’re using Git
more heavily, however, you may see much more information from git remote
show:
$ git remote show origin
* remote origin
URL: https://github.com/my-org/complex-project
Fetch URL: https://github.com/my-org/complex-project
Push URL: https://github.com/my-org/complex-project
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
markdown-strip tracked
issue-43 new (next fetch will store in remotes/origin)
issue-45 new (next fetch will store in remotes/origin)
refs/remotes/origin/issue-11 stale (use 'git remote prune' to remove)
Local branches configured for 'git pull':
dev-branch merges with remote dev-branch
master merges with remote master
Local refs configured for 'git push':
dev-branch pushes to dev-branch (up to date)
markdown-strip pushes to markdown-strip (up to date)
master pushes to master (up to date)
This command shows which branch is automatically pushed to when you
run git push while on certain branches. It also shows you which remote
branches on the server you don’t yet have, which remote branches you have
that have been removed from the server, and multiple local branches that are
able to merge automatically with their remote-tracking branch when you run
git pull.
Removing and Renaming Remotes
You can run git remote rename to change a remote’s shortname. For instance, if you want to rename pb to paul, you can do so with git remote rename:
$ git remote rename pb paul
$ git remote
origin
paul
Working with Remotes
73It’s worth mentioning that this changes all your remote-tracking branch
names, too. What used to be referenced at pb/master is now at paul/master.
If you want to remove a remote for some reason – you’ve moved the server
or are no longer using a particular mirror, or perhaps a contributor isn’t contributing anymore – you can use git remote rm:
$ git remote rm paul
$ git remote
origin
Tagging
Like most VCSs, Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and
so on). In this section, you’ll learn how to list the available tags, how to create
new tags, and what the different types of tags are.
Listing Your Tags
Listing the available tags in Git is straightforward. Just type git tag:
$ git tag
v0.1
v1.3
This command lists the tags in alphabetical order; the order in which they
appear has no real importance.
You can also search for tags with a particular pattern. The Git source repo,
for instance, contains more than 500 tags. If you’re only interested in looking at
the 1.8.5 series, you can run this:
$ git tag -l "v1.8.5*"
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
CHAPTER 2: Git Basics
74v1.8.5.4
v1.8.5.5
Creating Tags
Git uses two main types of tags: lightweight and annotated.
A lightweight tag is very much like a branch that doesn’t change – it’s just a
pointer to a specific commit.
Annotated tags, however, are stored as full objects in the Git database.
They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).
It’s generally recommended that you create annotated tags so you can have all
this information; but if you want a temporary tag or for some reason don’t want
to keep the other information, lightweight tags are available too.
Annotated Tags
Creating an annotated tag in Git is simple. The easiest way is to specify -a when
you run the tag command:
$ git tag -a v1.4 -m "my version 1.4"
$ git tag
v0.1
v1.3
v1.4
The -m specifies a tagging message, which is stored with the tag. If you don’t
specify a message for an annotated tag, Git launches your editor so you can
type it in.
You can see the tag data along with the commit that was tagged by using the
git show command:
$ git show v1.4
tag v1.4
Tagger: Ben Straub <ben@straub.cc>
Date: Sat May 3 20:19:12 2014 -0700
my version 1.4
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
Tagging
75changed the version number
That shows the tagger information, the date the commit was tagged, and the
annotation message before showing the commit information.
Lightweight Tags
Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file – no other information is kept. To create a lightweight tag, don’t supply the -a, -s, or -m option:
$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5
This time, if you run git show on the tag, you don’t see the extra tag information. The command just shows the commit:
$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
changed the version number
Tagging Later
You can also tag commits after you’ve moved past them. Suppose your commit
history looks like this:
$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
CHAPTER 2: Git Basics
76166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
Now, suppose you forgot to tag the project at v1.2, which was at the “updated rakefile” commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:
$ git tag -a v1.2 9fceb02
You can see that you’ve tagged the commit:
$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5
$ git show v1.2
tag v1.2
Tagger: Scott Chacon <schacon@gee-mail.com>
Date: Mon Feb 9 15:32:16 2009 -0800
version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon <mchacon@gee-mail.com>
Date: Sun Apr 27 20:43:35 2008 -0700
updated rakefile
...
Sharing Tags
By default, the git push command doesn’t transfer tags to remote servers.
You will have to explicitly push tags to a shared server after you have created
them. This process is just like sharing remote branches – you can run git push
origin [tagname].
$ git push origin v1.5
Counting objects: 14, done.
Tagging
77Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
* [new tag] v1.5 -> v1.5
If you have a lot of tags that you want to push up at once, you can also use
the --tags option to the git push command. This will transfer all of your tags
to the remote server that are not already there.
$ git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
* [new tag] v1.4 -> v1.4
* [new tag] v1.4-lw -> v1.4-lw
Now, when someone else clones or pulls from your repository, they will get
all your tags as well.
Checking out Tags
You can’t really check out a tag in Git, since they can’t be moved around. If you
want to put a version of your repository in your working directory that looks
like a specific tag, you can create a new branch at a specific tag with git
checkout -b [branchname] [tagname]:
$ git checkout -b version2 v2.0.0
Switched to a new branch 'version2'
Of course if you do this and do a commit, your version2 branch will be
slightly different than your v2.0.0 tag since it will move forward with your new
changes, so do be careful.
Git Aliases
Before we finish this chapter on basic Git, there’s just one little tip that can
make your Git experience simpler, easier, and more familiar: aliases. We won’t
CHAPTER 2: Git Basics
78refer to them or assume you’ve used them later in the book, but you should
probably know how to use them.
Git doesn’t automatically infer your command if you type it in partially. If
you don’t want to type the entire text of each of the Git commands, you can
easily set up an alias for each command using git config. Here are a couple
of examples you may want to set up:
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
This means that, for example, instead of typing git commit, you just need
to type git ci. As you go on using Git, you’ll probably use other commands
frequently as well; don’t hesitate to create new aliases.
This technique can also be very useful in creating commands that you think
should exist. For example, to correct the usability problem you encountered
with unstaging a file, you can add your own unstage alias to Git:
$ git config --global alias.unstage 'reset HEAD --'
This makes the following two commands equivalent:
$ git unstage fileA
$ git reset HEAD -- fileA
This seems a bit clearer. It’s also common to add a last command, like this:
$ git config --global alias.last 'log -1 HEAD'
This way, you can see the last commit easily:
$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <dreamer3@example.com>
Date: Tue Aug 26 19:48:51 2008 +0800
test for current head
Git Aliases
79Signed-off-by: Scott Chacon <schacon@example.com>
As you can tell, Git simply replaces the new command with whatever you
alias it for. However, maybe you want to run an external command, rather than
a Git subcommand. In that case, you start the command with a ! character. This
is useful if you write your own tools that work with a Git repository. We can
demonstrate by aliasing git visual to run gitk:
$ git config --global alias.visual '!gitk'
Summary
At this point, you can do all the basic local Git operations – creating or cloning a
repository, making changes, staging and committing those changes, and viewing the history of all the changes the repository has been through. Next, we’ll
cover Git’s killer feature: its branching model.
CHAPTER 2: Git Basics
80Git Branching
Nearly every VCS has some form of branching support. Branching means you
diverge from the main line of development and continue to do work without
messing with that main line. In many VCS tools, this is a somewhat expensive
process, often requiring you to create a new copy of your source code directory,
which can take a long time for large projects.
Some people refer to Git’s branching model as its “killer feature,” and it certainly sets Git apart in the VCS community. Why is it so special? The way Git
branches is incredibly lightweight, making branching operations nearly instantaneous, and switching back and forth between branches generally just as fast.
Unlike many other VCSs, Git encourages workflows that branch and merge
often, even multiple times in a day. Understanding and mastering this feature
gives you a powerful and unique tool and can entirely change the way that you
develop.
Branches in a Nutshell
To really understand the way Git does branching, we need to take a step back
and examine how Git stores its data.
As you may remember from Chapter 1, Git doesn’t store data as a series of
changesets or differences, but instead as a series of snapshots.
When you make a commit, Git stores a commit object that contains a pointer
to the snapshot of the content you staged. This object also contains the author’s name and email, the message that you typed, and pointers to the commit
or commits that directly came before this commit (its parent or parents): zero
parents for the initial commit, one parent for a normal commit, and multiple
parents for a commit that results from a merge of two or more branches.
To visualize this, let’s assume that you have a directory containing three
files, and you stage them all and commit. Staging the files checksums each one
(the SHA-1 hash we mentioned in Chapter 1), stores that version of the file in
81
3FIGURE 3-1
A commit and its
tree
the Git repository (Git refers to them as blobs), and adds that checksum to the
staging area:
$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'
When you create the commit by running git commit, Git checksums each
subdirectory (in this case, just the root project directory) and stores those tree
objects in the Git repository. Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot
when needed.
Your Git repository now contains five objects: one blob for the contents of
each of your three files, one tree that lists the contents of the directory and
specifies which file names are stored as which blobs, and one commit with the
pointer to that root tree and all the commit metadata.
If you make some changes and commit again, the next commit stores a
pointer to the commit that came immediately before it.
CHAPTER 3: Git Branching
82FIGURE 3-2
Commits and their
parents
FIGURE 3-3
A branch and its
commit history
A branch in Git is simply a lightweight movable pointer to one of these commits. The default branch name in Git is master. As you start making commits,
you’re given a master branch that points to the last commit you made. Every
time you commit, it moves forward automatically.
The “master” branch in Git is not a special branch. It is exactly like any
other branch. The only reason nearly every repository has one is that the
git init command creates it by default and most people don’t bother to
change it.
Branches in a Nutshell
83FIGURE 3-4
Two branches
pointing into the
same series of
commits
Creating a New Branch
What happens if you create a new branch? Well, doing so creates a new pointer
for you to move around. Let’s say you create a new branch called testing. You
do this with the git branch command:
$ git branch testing
This creates a new pointer to the same commit you’re currently on.
How does Git know what branch you’re currently on? It keeps a special
pointer called HEAD. Note that this is a lot different than the concept of HEAD in
other VCSs you may be used to, such as Subversion or CVS. In Git, this is a pointer to the local branch you’re currently on. In this case, you’re still on master.
The git branch command only created a new branch – it didn’t switch to that
branch.
CHAPTER 3: Git Branching
84FIGURE 3-5
HEAD pointing to a
branch
You can easily see this by running a simple git log command that shows
you where the branch pointers are pointing. This option is called --decorate.
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project
You can see the “master” and “testing” branches that are right there next to
the f30ab commit.
Switching Branches
To switch to an existing branch, you run the git checkout command. Let’s
switch to the new testing branch:
$ git checkout testing
This moves HEAD to point to the testing branch.
Branches in a Nutshell
85FIGURE 3-6
HEAD points to the
current branch
FIGURE 3-7
The HEAD branch
moves forward
when a commit is
made
What is the significance of that? Well, let’s do another commit:
$ vim test.rb
$ git commit -a -m 'made a change'
This is interesting, because now your testing branch has moved forward,
but your master branch still points to the commit you were on when you ran
git checkout to switch branches. Let’s switch back to the master branch:
CHAPTER 3: Git Branching
86FIGURE 3-8
HEAD moves when
you checkout
$ git checkout master
That command did two things. It moved the HEAD pointer back to point to
the master branch, and it reverted the files in your working directory back to
the snapshot that master points to. This also means the changes you make
from this point forward will diverge from an older version of the project. It essentially rewinds the work you’ve done in your testing branch so you can go
in a different direction.
SWITCHING BRANCHES CHANGES FILES IN YOUR WORKING
DIRECTORY
It’s important to note that when you switch branches in Git, files in your
working directory will change. If you switch to an older branch, your
working directory will be reverted to look like it did the last time you
committed on that branch. If Git cannot do it cleanly, it will not let you
switch at all.
Let’s make a few changes and commit again:
$ vim test.rb
$ git commit -a -m 'made other changes'
Now your project history has diverged (see Figure 3-9). You created and
switched to a branch, did some work on it, and then switched back to your
main branch and did other work. Both of those changes are isolated in separate
branches: you can switch back and forth between the branches and merge
Branches in a Nutshell
87FIGURE 3-9
Divergent history
them together when you’re ready. And you did all that with simple branch,
checkout, and commit commands.
You can also see this easily with the git log command. If you run git log
--oneline --decorate --graph --all it will print out the history of your
commits, showing where your branch pointers are and how your history has diverged.
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create
and destroy. Creating a new branch is as quick and simple as writing 41 bytes to
a file (40 characters and a newline).
This is in sharp contrast to the way most older VCS tools branch, which involves copying all of the project’s files into a second directory. This can take
several seconds or even minutes, depending on the size of the project, whereas
CHAPTER 3: Git Branching
88FIGURE 3-10
A simple commit
history
in Git the process is always instantaneous. Also, because we’re recording the
parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do. These features help encourage developers to create and use branches often.
Let’s see why you should do so.
Basic Branching and Merging
Let’s go through a simple example of branching and merging with a workflow
that you might use in the real world. You’ll follow these steps:
1. Do work on a web site.
2. Create a branch for a new story you’re working on.
3. Do some work in that branch.
At this stage, you’ll receive a call that another issue is critical and you need a
hotfix. You’ll do the following:
1. Switch to your production branch.
2. Create a branch to add the hotfix.
3. After it’s tested, merge the hotfix branch, and push to production.
4. Switch back to your original story and continue working.
Basic Branching
First, let’s say you’re working on your project and have a couple of commits already.
You’ve decided that you’re going to work on issue #53 in whatever issuetracking system your company uses. To create a branch and switch to it at the
same time, you can run the git checkout command with the -b switch:
Basic Branching and Merging
89FIGURE 3-11
Creating a new
branch pointer
$ git checkout -b iss53
Switched to a new branch "iss53"
This is shorthand for:
$ git branch iss53
$ git checkout iss53
You work on your web site and do some commits. Doing so moves the iss53
branch forward, because you have it checked out (that is, your HEAD is pointing
to it):
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
CHAPTER 3: Git Branching
90FIGURE 3-12
The iss53 branch has
moved forward with
your work
Now you get the call that there is an issue with the web site, and you need to
fix it immediately. With Git, you don’t have to deploy your fix along with the
iss53 changes you’ve made, and you don’t have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in
production. All you have to do is switch back to your master branch.
However, before you do that, note that if your working directory or staging
area has uncommitted changes that conflict with the branch you’re checking
out, Git won’t let you switch branches. It’s best to have a clean working state
when you switch branches. There are ways to get around this (namely, stashing
and commit amending) that we’ll cover later on, in “Stashing and Cleaning”.
For now, let’s assume you’ve committed all your changes, so you can switch
back to your master branch:
$ git checkout master
Switched to branch 'master'
At this point, your project working directory is exactly the way it was before
you started working on issue #53, and you can concentrate on your hotfix. This
is an important point to remember: when you switch branches, Git resets your
working directory to look like it did the last time you committed on that branch.
It adds, removes, and modifies files automatically to make sure your working
copy is what the branch looked like on your last commit to it.
Next, you have a hotfix to make. Let’s create a hotfix branch on which to
work until it’s completed:
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
Basic Branching and Merging
91FIGURE 3-13
Hotfix branch based
on master
[hotfix 1fb7853] fixed the broken email address
1 file changed, 2 insertions(+)
You can run your tests, make sure the hotfix is what you want, and merge it
back into your master branch to deploy to production. You do this with the git
merge command:
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
index.html | 2 ++
1 file changed, 2 insertions(+)
You’ll notice the phrase “fast-forward” in that merge. Because the commit C4
pointed to by the branch hotfix you merged in was directly ahead of the commit C2 you’re on, Git simply moves the pointer forward. To phrase that another
way, when you try to merge one commit with a commit that can be reached by
following the first commit’s history, Git simplifies things by moving the pointer
forward because there is no divergent work to merge together – this is called a
“fast-forward.”
Your change is now in the snapshot of the commit pointed to by the master
branch, and you can deploy the fix.
CHAPTER 3: Git Branching
92FIGURE 3-14
master is fastforwarded to hotfix
After your super-important fix is deployed, you’re ready to switch back to the
work you were doing before you were interrupted. However, first you’ll delete
the hotfix branch, because you no longer need it – the master branch points
at the same place. You can delete it with the -d option to git branch:
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
Now you can switch back to your work-in-progress branch on issue #53 and
continue working on it.
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
Basic Branching and Merging
93FIGURE 3-15
Work continues on
iss53
It’s worth noting here that the work you did in your hotfix branch is not
contained in the files in your iss53 branch. If you need to pull it in, you can
merge your master branch into your iss53 branch by running git merge
master, or you can wait to integrate those changes until you decide to pull the
iss53 branch back into master later.
Basic Merging
Suppose you’ve decided that your issue #53 work is complete and ready to be
merged into your master branch. In order to do that, you’ll merge your iss53
branch into master, much like you merged your hotfix branch earlier. All you
have to do is check out the branch you wish to merge into and then run the git
merge command:
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html | 1 +
1 file changed, 1 insertion(+)
This looks a bit different than the hotfix merge you did earlier. In this case,
your development history has diverged from some older point. Because the
commit on the branch you’re on isn’t a direct ancestor of the branch you’re
merging in, Git has to do some work. In this case, Git does a simple three-way
CHAPTER 3: Git Branching
94FIGURE 3-16
Three snapshots
used in a typical
merge
FIGURE 3-17
A merge commit
merge, using the two snapshots pointed to by the branch tips and the common
ancestor of the two.
Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new
commit that points to it. This is referred to as a merge commit, and is special in
that it has more than one parent.
It’s worth pointing out that Git determines the best common ancestor to use
for its merge base; this is different than older tools like CVS or Subversion (before version 1.5), where the developer doing the merge had to figure out the
best merge base for themselves. This makes merging a heck of a lot easier in Git
than in these other systems.
Basic Branching and Merging
95Now that your work is merged in, you have no further need for the iss53
branch. You can close the ticket in your ticket-tracking system, and delete the
branch:
$ git branch -d iss53
Basic Merge Conflicts
Occasionally, this process doesn’t go smoothly. If you changed the same part of
the same file differently in the two branches you’re merging together, Git won’t
be able to merge them cleanly. If your fix for issue #53 modified the same part
of a file as the hotfix, you’ll get a merge conflict that looks something like this:
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
Git hasn’t automatically created a new merge commit. It has paused the process while you resolve the conflict. If you want to see which files are unmerged
at any point after a merge conflict, you can run git status:
$ git status
On branch master
You have unmerged paths.
(fix conflicts and run "git commit")
Unmerged paths:
(use "git add <file>..." to mark resolution)
both modified: index.html
no changes added to commit (use "git add" and/or "git commit -a")
Anything that has merge conflicts and hasn’t been resolved is listed as unmerged. Git adds standard conflict-resolution markers to the files that have
conflicts, so you can open them manually and resolve those conflicts. Your file
contains a section that looks something like this:
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
CHAPTER 3: Git Branching
96=======
<div id="footer">
please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
This means the version in HEAD (your master branch, because that was what
you had checked out when you ran your merge command) is the top part of
that block (everything above the =======), while the version in your iss53
branch looks like everything in the bottom part. In order to resolve the conflict,
you have to either choose one side or the other or merge the contents yourself.
For instance, you might resolve this conflict by replacing the entire block with
this:
<div id="footer">
please contact us at email.support@github.com
</div>
This resolution has a little of each section, and the <<<<<<<, =======, and
>>>>>>> lines have been completely removed. After you’ve resolved each of
these sections in each conflicted file, run git add on each file to mark it as resolved. Staging the file marks it as resolved in Git.
If you want to use a graphical tool to resolve these issues, you can run git
mergetool, which fires up an appropriate visual merge tool and walks you
through the conflicts:
$ git mergetool
This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge
Merging:
index.html
Normal merge conflict for 'index.html':
{local}: modified file
{remote}: modified file
Hit return to start merge resolution tool (opendiff):
If you want to use a merge tool other than the default (Git chose opendiff
in this case because the command was run on a Mac), you can see all the supported tools listed at the top after “one of the following tools.” Just type the
name of the tool you’d rather use.
Basic Branching and Merging
97If you need more advanced tools for resolving tricky merge conflicts, we
cover more on merging in “Advanced Merging”.
After you exit the merge tool, Git asks you if the merge was successful. If you
tell the script that it was, it stages the file to mark it as resolved for you. You can
run git status again to verify that all conflicts have been resolved:
$ git status
On branch master
All conflicts fixed but you are still merging.
(use "git commit" to conclude merge)
Changes to be committed:
modified: index.html
If you’re happy with that, and you verify that everything that had conflicts
has been staged, you can type git commit to finalize the merge commit. The
commit message by default looks something like this:
Merge branch 'iss53'
Conflicts:
index.html
# #
It looks like you may be committing a merge.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
# #
Changes to be committed:
# modified: index.html
#
You can modify that message with details about how you resolved the merge
if you think it would be helpful to others looking at this merge in the future –
why you did what you did, if it’s not obvious.
CHAPTER 3: Git Branching
98Branch Management
Now that you’ve created, merged, and deleted some branches, let’s look at
some branch-management tools that will come in handy when you begin using
branches all the time.
The git branch command does more than just create and delete branches.
If you run it with no arguments, you get a simple listing of your current branches:
$ git branch
iss53
* master
testing
Notice the * character that prefixes the master branch: it indicates the
branch that you currently have checked out (i.e., the branch that HEAD points
to). This means that if you commit at this point, the master branch will be
moved forward with your new work. To see the last commit on each branch,
you can run git branch -v:
$ git branch -v
iss53 93b412c fix javascript issue
* master 7a98805 Merge branch 'iss53'
testing 782fd34 add scott to the author list in the readmes
The useful --merged and --no-merged options can filter this list to branches that you have or have not yet merged into the branch you’re currently on. To
see which branches are already merged into the branch you’re on, you can run
git branch --merged:
$ git branch --merged
iss53
* master
Because you already merged in iss53 earlier, you see it in your list. Branches on this list without the * in front of them are generally fine to delete with git
branch -d; you’ve already incorporated their work into another branch, so
you’re not going to lose anything.
To see all the branches that contain work you haven’t yet merged in, you can
run git branch --no-merged:
Branch Management
99$ git branch --no-merged
testing
This shows your other branch. Because it contains work that isn’t merged in
yet, trying to delete it with git branch -d will fail:
$ git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
If you really do want to delete the branch and lose that work, you can force it
with -D, as the helpful message points out.
Branching Workflows
Now that you have the basics of branching and merging down, what can or
should you do with them? In this section, we’ll cover some common workflows
that this lightweight branching makes possible, so you can decide if you would
like to incorporate it into your own development cycle.
Long-Running Branches
Because Git uses a simple three-way merge, merging from one branch into another multiple times over a long period is generally easy to do. This means you
can have several branches that are always open and that you use for different
stages of your development cycle; you can merge regularly from some of them
into others.
Many Git developers have a workflow that embraces this approach, such as
having only code that is entirely stable in their master branch – possibly only
code that has been or will be released. They have another parallel branch
named develop or next that they work from or use to test stability – it isn’t
necessarily always stable, but whenever it gets to a stable state, it can be
merged into master. It’s used to pull in topic branches (short-lived branches,
like your earlier iss53 branch) when they’re ready, to make sure they pass all
the tests and don’t introduce bugs.
In reality, we’re talking about pointers moving up the line of commits you’re
making. The stable branches are farther down the line in your commit history,
and the bleeding-edge branches are farther up the history.
CHAPTER 3: Git Branching
100FIGURE 3-18
A linear view of
progressive-stability
branching
FIGURE 3-19
A “silo” view of
progressive-stability
branching
It’s generally easier to think about them as work silos, where sets of commits
graduate to a more stable silo when they’re fully tested.
You can keep doing this for several levels of stability. Some larger projects
also have a proposed or pu (proposed updates) branch that has integrated
branches that may not be ready to go into the next or master branch. The idea
is that your branches are at various levels of stability; when they reach a more
stable level, they’re merged into the branch above them. Again, having multiple
long-running branches isn’t necessary, but it’s often helpful, especially when
you’re dealing with very large or complex projects.
Topic Branches
Topic branches, however, are useful in projects of any size. A topic branch is a
short-lived branch that you create and use for a single particular feature or related work. This is something you’ve likely never done with a VCS before because it’s generally too expensive to create and merge branches. But in Git it’s
common to create, work on, merge, and delete branches several times a day.
You saw this in the last section with the iss53 and hotfix branches you
created. You did a few commits on them and deleted them directly after merging them into your main branch. This technique allows you to context-switch
quickly and completely – because your work is separated into silos where all
Branching Workflows
101FIGURE 3-20
Multiple topic
branches
the changes in that branch have to do with that topic, it’s easier to see what has
happened during code review and such. You can keep the changes there for minutes, days, or months, and merge them in when they’re ready, regardless of
the order in which they were created or worked on.
Consider an example of doing some work (on master), branching off for an
issue (iss91), working on it for a bit, branching off the second branch to try another way of handling the same thing (iss91v2), going back to your master
branch and working there for a while, and then branching off there to do some
work that you’re not sure is a good idea (dumbidea branch). Your commit history will look something like this:
Now, let’s say you decide you like the second solution to your issue best
(iss91v2); and you showed the dumbidea branch to your coworkers, and it
turns out to be genius. You can throw away the original iss91 branch (losing
commits C5 and C6) and merge in the other two. Your history then looks like
this:
CHAPTER 3: Git Branching
102FIGURE 3-21
History after
merging dumbidea
and iss91v2
We will go into more detail about the various possible workflows for your Git
project in Chapter 5, so before you decide which branching scheme your next
project will use, be sure to read that chapter.
It’s important to remember when you’re doing all this that these branches
are completely local. When you’re branching and merging, everything is being
done only in your Git repository – no server communication is happening.
Remote Branches
Remote references are references (pointers) in your remote repositories, including branches, tags, and so on. You can get a full list of remote references explicitly with git ls-remote [remote], or git remote show [remote] for reRemote Branches
103mote branches as well as more information. Nevertheless, a more common way
is to take advantage of remote-tracking branches.
Remote-tracking branches are references to the state of remote branches.
They’re local references that you can’t move; they’re moved automatically for
you whenever you do any network communication. Remote-tracking branches
act as bookmarks to remind you where the branches in your remote repositories were the last time you connected to them.
They take the form (remote)/(branch). For instance, if you wanted to see
what the master branch on your origin remote looked like as of the last time
you communicated with it, you would check the origin/master branch. If you
were working on an issue with a partner and they pushed up an iss53 branch,
you might have your own local iss53 branch; but the branch on the server
would point to the commit at origin/iss53.
This may be a bit confusing, so let’s look at an example. Let’s say you have a
Git server on your network at git.ourcompany.com. If you clone from this,
Git’s clone command automatically names it origin for you, pulls down all its
data, creates a pointer to where its master branch is, and names it origin/
master locally. Git also gives you your own local master branch starting at the
same place as origin’s master branch, so you have something to work from.
“ORIGIN” IS NOT SPECIAL
Just like the branch name “master” does not have any special meaning
in Git, neither does “origin”. While “master” is the default name for a
starting branch when you run git init which is the only reason it’s
widely used, “origin” is the default name for a remote when you run git
clone. If you run git clone -o booyah instead, then you will have booyah/
master as your default remote branch.
CHAPTER 3: Git Branching
104FIGURE 3-22
Server and local
repositories after
cloning
If you do some work on your local master branch, and, in the meantime,
someone else pushes to git.ourcompany.com and updates its master
branch, then your histories move forward differently. Also, as long as you stay
out of contact with your origin server, your origin/master pointer doesn’t
move.
Remote Branches
105FIGURE 3-23
Local and remote
work can diverge
To synchronize your work, you run a git fetch origin command. This
command looks up which server “origin” is (in this case, it’s git.ourcompany.com), fetches any data from it that you don’t yet have, and updates your local database, moving your origin/master pointer to its new, more up-to-date
position.
CHAPTER 3: Git Branching
106FIGURE 3-24
git fetch updates
your remote
references
To demonstrate having multiple remote servers and what remote branches
for those remote projects look like, let’s assume you have another internal Git
server that is used only for development by one of your sprint teams. This server is at git.team1.ourcompany.com. You can add it as a new remote reference to the project you’re currently working on by running the git remote
add command as we covered in Chapter 2. Name this remote teamone, which
will be your shortname for that whole URL.
Remote Branches
107FIGURE 3-25
Adding another
server as a remote
Now, you can run git fetch teamone to fetch everything the remote
teamone server has that you don’t have yet. Because that server has a subset of
the data your origin server has right now, Git fetches no data but sets a
remote-tracking branch called teamone/master to point to the commit that
teamone has as its master branch.
CHAPTER 3: Git Branching
108FIGURE 3-26
Remote tracking
branch for teamone/
master
Pushing
When you want to share a branch with the world, you need to push it up to a
remote that you have write access to. Your local branches aren’t automatically
synchronized to the remotes you write to – you have to explicitly push the
branches you want to share. That way, you can use private branches for work
you don’t want to share, and push up only the topic branches you want to collaborate on.
If you have a branch named serverfix that you want to work on with others, you can push it up the same way you pushed your first branch. Run git
push <remote> <branch>:
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
* [new branch] serverfix -> serverfix
Remote Branches
109This is a bit of a shortcut. Git automatically expands the serverfix branchname out to refs/heads/serverfix:refs/heads/serverfix, which
means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” We’ll go over the refs/heads/ part in detail in Chapter 10, but
you can generally leave it off. You can also do git push origin serverfix:serverfix, which does the same thing – it says, “Take my serverfix and
make it the remote’s serverfix.” You can use this format to push a local branch
into a remote branch that is named differently. If you didn’t want it to be called
serverfix on the remote, you could instead run git push origin serverfix:awesomebranch to push your local serverfix branch to the awesomebranch branch on the remote project.
DON’T TYPE YOUR PASSWORD EVERY TIME
If you’re using an HTTPS URL to push over, the Git server will ask you for
your username and password for authentication. By default it will
prompt you on the terminal for this information so the server can tell if
you’re allowed to push.
If you don’t want to type it every single time you push, you can set up a
“credential cache”. The simplest is just to keep it in memory for a few
minutes, which you can easily set up by running git config --global
credential.helper cache.
For more information on the various credential caching options available, see “Credential Storage”.
The next time one of your collaborators fetches from the server, they will get
a reference to where the server’s version of serverfix is under the remote
branch origin/serverfix:
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
* [new branch] serverfix -> origin/serverfix
It’s important to note that when you do a fetch that brings down new
remote-tracking branches, you don’t automatically have local, editable copies
of them. In other words, in this case, you don’t have a new serverfix branch –
you only have an origin/serverfix pointer that you can’t modify.
CHAPTER 3: Git Branching
110To merge this work into your current working branch, you can run git
merge origin/serverfix. If you want your own serverfix branch that you
can work on, you can base it off your remote-tracking branch:
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
This gives you a local branch that you can work on that starts where origin/serverfix is.
Tracking Branches
Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch” (and the branch it tracks is called an
“upstream branch”). Tracking branches are local branches that have a direct relationship to a remote branch. If you’re on a tracking branch and type git
pull, Git automatically knows which server to fetch from and branch to merge
into.
When you clone a repository, it generally automatically creates a master
branch that tracks origin/master. However, you can set up other tracking
branches if you wish – ones that track branches on other remotes, or don’t
track the master branch. The simple case is the example you just saw, running
git checkout -b [branch] [remotename]/[branch]. This is a common
enough operation that git provides the --track shorthand:
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
In fact, this is so common that there’s even a shortcut for that shortcut. If the
branch name you’re trying to checkout (a) doesn’t exist and (b) exactly matches
a name on only one remote, Git will create a tracking branch for you:
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
Remote Branches
111To set up a local branch with a different name than the remote branch, you
can easily use the first version with a different local branch name:
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
Now, your local branch sf will automatically pull from origin/serverfix.
If you already have a local branch and want to set it to a remote branch you
just pulled down, or want to change the upstream branch you’re tracking, you
can use the -u or --set-upstream-to option to git branch to explicitly set
it at any time.
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
UPSTREAM SHORTHAND
When you have a tracking branch set up, you can reference its upstream
branch with the @{upstream} or @{u} shorthand. So if you’re on the master
branch and it’s tracking origin/master, you can say something like git
merge @{u} instead of git merge origin/master if you wish.
If you want to see what tracking branches you have set up, you can use the -
vv option to git branch. This will list out your local branches with more information including what each branch is tracking and if your local branch is
ahead, behind or both.
$ git branch -vv
iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
master 1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
testing 5ea463a trying something new
So here we can see that our iss53 branch is tracking origin/iss53 and is
“ahead” by two, meaning that we have two commits locally that are not pushed
to the server. We can also see that our master branch is tracking origin/
master and is up to date. Next we can see that our serverfix branch is tracking the server-fix-good branch on our teamone server and is ahead by three
and behind by one, meaning that there is one commit on the server we haven’t
CHAPTER 3: Git Branching
112merged in yet and three commits locally that we haven’t pushed. Finally we can
see that our testing branch is not tracking any remote branch.
It’s important to note that these numbers are only since the last time you
fetched from each server. This command does not reach out to the servers, it’s
telling you about what it has cached from these servers locally. If you want totally up to date ahead and behind numbers, you’ll need to fetch from all your
remotes right before running this. You could do that like this: git fetch --
all; git branch -vv
Pulling
While the git fetch command will fetch down all the changes on the server
that you don’t have yet, it will not modify your working directory at all. It will
simply get the data for you and let you merge it yourself. However, there is a
command called git pull which is essentially a git fetch immediately followed by a git merge in most cases. If you have a tracking branch set up as
demonstrated in the last section, either by explicitly setting it or by having it
created for you by the clone or checkout commands, git pull will look up
what server and branch your current branch is tracking, fetch from that server
and then try to merge in that remote branch.
Generally it’s better to simply use the fetch and merge commands explicitly
as the magic of git pull can often be confusing.
Deleting Remote Branches
Suppose you’re done with a remote branch – say you and your collaborators
are finished with a feature and have merged it into your remote’s master
branch (or whatever branch your stable codeline is in). You can delete a remote
branch using the --delete option to git push. If you want to delete your
serverfix branch from the server, you run the following:
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
- [deleted] serverfix
Basically all this does is remove the pointer from the server. The Git server
will generally keep the data there for a while until a garbage collection runs, so
if it was accidentally deleted, it’s often easy to recover.
Remote Branches
113FIGURE 3-27
Simple divergent
history
Rebasing
In Git, there are two main ways to integrate changes from one branch into another: the merge and the rebase. In this section you’ll learn what rebasing is,
how to do it, why it’s a pretty amazing tool, and in what cases you won’t want
to use it.
The Basic Rebase
If you go back to an earlier example from “Basic Merging”, you can see that
you diverged your work and made commits on two different branches.
The easiest way to integrate the branches, as we’ve already covered, is the
merge command. It performs a three-way merge between the two latest branch
snapshots (C3 and C4) and the most recent common ancestor of the two (C2),
creating a new snapshot (and commit).
CHAPTER 3: Git Branching
114FIGURE 3-28
Merging to integrate
diverged work
history
FIGURE 3-29
Rebasing the change
introduced in C4
onto C3
However, there is another way: you can take the patch of the change that
was introduced in C4 and reapply it on top of C3. In Git, this is called rebasing.
With the rebase command, you can take all the changes that were committed
on one branch and replay them on another one.
In this example, you’d run the following:
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
It works by going to the common ancestor of the two branches (the one
you’re on and the one you’re rebasing onto), getting the diff introduced by each
commit of the branch you’re on, saving those diffs to temporary files, resetting
the current branch to the same commit as the branch you are rebasing onto,
and finally applying each change in turn.
Rebasing
115FIGURE 3-30
Fast-forwarding the
master branch
At this point, you can go back to the master branch and do a fast-forward
merge.
$ git checkout master
$ git merge experiment
Now, the snapshot pointed to by C4' is exactly the same as the one that was
pointed to by C5 in the merge example. There is no difference in the end product of the integration, but rebasing makes for a cleaner history. If you examine
the log of a rebased branch, it looks like a linear history: it appears that all the
work happened in series, even when it originally happened in parallel.
Often, you’ll do this to make sure your commits apply cleanly on a remote
branch – perhaps in a project to which you’re trying to contribute but that you
don’t maintain. In this case, you’d do your work in a branch and then rebase
your work onto origin/master when you were ready to submit your patches
to the main project. That way, the maintainer doesn’t have to do any integration work – just a fast-forward or a clean apply.
Note that the snapshot pointed to by the final commit you end up with,
whether it’s the last of the rebased commits for a rebase or the final merge
commit after a merge, is the same snapshot – it’s only the history that is different. Rebasing replays changes from one line of work onto another in the order
they were introduced, whereas merging takes the endpoints and merges them
together.
More Interesting Rebases
You can also have your rebase replay on something other than the rebase target
branch. Take a history like Figure 3-31, for example. You branched a topic
branch (server) to add some server-side functionality to your project, and
made a commit. Then, you branched off that to make the client-side changes
CHAPTER 3: Git Branching
116FIGURE 3-31
A history with a
topic branch off
another topic branch
(client) and committed a few times. Finally, you went back to your server
branch and did a few more commits.
Suppose you decide that you want to merge your client-side changes into
your mainline for a release, but you want to hold off on the server-side changes
until it’s tested further. You can take the changes on client that aren’t on server
(C8 and C9) and replay them on your master branch by using the --onto option of git rebase:
$ git rebase --onto master server client
This basically says, “Check out the client branch, figure out the patches from
the common ancestor of the client and server branches, and then replay
them onto master.” It’s a bit complex, but the result is pretty cool.
Rebasing
117FIGURE 3-32
Rebasing a topic
branch off another
topic branch
FIGURE 3-33
Fast-forwarding
your master branch
to include the client
branch changes
Now you can fast-forward your master branch (see Figure 3-33):
$ git checkout master
$ git merge client
Let’s say you decide to pull in your server branch as well. You can rebase the
server branch onto the master branch without having to check it out first by
running git rebase [basebranch] [topicbranch] – which checks out the
topic branch (in this case, server) for you and replays it onto the base branch
(master):
$ git rebase master server
This replays your server work on top of your master work, as shown in
Figure 3-34.
CHAPTER 3: Git Branching
118FIGURE 3-34
Rebasing your server
branch on top of
your master branch
FIGURE 3-35
Final commit history
Then, you can fast-forward the base branch (master):
$ git checkout master
$ git merge server
You can remove the client and server branches because all the work is
integrated and you don’t need them anymore, leaving your history for this entire process looking like Figure 3-35:
$ git branch -d client
$ git branch -d server
The Perils of Rebasing
Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be summed up in a single line:
Do not rebase commits that exist outside your repository.
If you follow that guideline, you’ll be fine. If you don’t, people will hate you,
and you’ll be scorned by friends and family.
When you rebase stuff, you’re abandoning existing commits and creating
new ones that are similar but different. If you push commits somewhere and
others pull them down and base work on them, and then you rewrite those
commits with git rebase and push them up again, your collaborators will
have to re-merge their work and things will get messy when you try to pull their
work back into yours.
Rebasing
119FIGURE 3-36
Clone a repository,
and base some work
on it
Let’s look at an example of how rebasing work that you’ve made public can
cause problems. Suppose you clone from a central server and then do some
work off that. Your commit history looks like this:
Now, someone else does more work that includes a merge, and pushes that
work to the central server. You fetch it and merge the new remote branch into
your work, making your history look something like this:
CHAPTER 3: Git Branching
120FIGURE 3-37
Fetch more commits,
and merge them
into your work
FIGURE 3-38
Someone pushes
rebased commits,
abandoning
commits you’ve
based your work on
Next, the person who pushed the merged work decides to go back and rebase their work instead; they do a git push --force to overwrite the history
on the server. You then fetch from that server, bringing down the new commits.
Rebasing
121FIGURE 3-39
You merge in the
same work again
into a new merge
commit
Now you’re both in a pickle. If you do a git pull, you’ll create a merge
commit which includes both lines of history, and your repository will look like
this:
If you run a git log when your history looks like this, you’ll see two commits that have the same author, date, and message, which will be confusing.
Furthermore, if you push this history back up to the server, you’ll reintroduce all
those rebased commits to the central server, which can further confuse people.
It’s pretty safe to assume that the other developer doesn’t want C4 and C6 to be
in the history; that’s why they rebased in the first place.
Rebase When You Rebase
If you do find yourself in a situation like this, Git has some further magic that
might help you out. If someone on your team force pushes changes that overwrite work that you’ve based work on, your challenge is to figure out what is
yours and what they’ve rewritten.
It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit.
This is called a “patch-id”.
If you pull down work that was rewritten and rebase it on top of the new
commits from your partner, Git can often successfully figure out what is uniquely yours and apply them back on top of the new branch.
For instance, in the previous scenario, if instead of doing a merge when
we’re at Figure 3-38 we run git rebase teamone/master, Git will:
CHAPTER 3: Git Branching
122FIGURE 3-40
Rebase on top of
force-pushed rebase
work.
• Determine what work is unique to our branch (C2, C3, C4, C6, C7)
• Determine which are not merge commits (C2, C3, C4)
• Determine which have not been rewritten into the target branch (just C2
and C3, since C4 is the same patch as C4')
• Apply those commits to the top of teamone/master
So instead of the result we see in Figure 3-39, we would end up with something more like Figure 3-40.
This only works if C4 and C4’ that your partner made are almost exactly the
same patch. Otherwise the rebase won’t be able to tell that it’s a duplicate and
will add another C4-like patch (which will probably fail to apply cleanly, since
the changes would already be at least somewhat there).
You can also simplify this by running a git pull --rebase instead of a
normal git pull. Or you could do it manually with a git fetch followed by a
git rebase teamone/master in this case.
If you are using git pull and want to make --rebase the default, you can
set the pull.rebase config value with something like git config --global
pull.rebase true.
If you treat rebasing as a way to clean up and work with commits before you
push them, and if you only rebase commits that have never been available publicly, then you’ll be fine. If you rebase commits that have already been pushed
publicly, and people may have based work on those commits, then you may be
in for some frustrating trouble, and the scorn of your teammates.
Rebasing
123If you or a partner does find it necessary at some point, make sure everyone
knows to run git pull --rebase to try to make the pain after it happens a
little bit simpler.
Rebase vs. Merge
Now that you’ve seen rebasing and merging in action, you may be wondering
which one is better. Before we can answer this, let’s step back a bit and talk
about what history means.
One point of view on this is that your repository’s commit history is a record
of what actually happened. It’s a historical document, valuable in its own
right, and shouldn’t be tampered with. From this angle, changing the commit
history is almost blasphemous; you’re lying about what actually transpired. So
what if there was a messy series of merge commits? That’s how it happened,
and the repository should preserve that for posterity.
The opposing point of view is that the commit history is the story of how
your project was made. You wouldn’t publish the first draft of a book, and the
manual for how to maintain your software deserves careful editing. This is the
camp that uses tools like rebase and filter-branch to tell the story in the way
that’s best for future readers.
Now, to the question of whether merging or rebasing is better: hopefully
you’ll see that it’s not that simple. Git is a powerful tool, and allows you to do
many things to and with your history, but every team and every project is different. Now that you know how both of these things work, it’s up to you to decide
which one is best for your particular situation.
In general the way to get the best of both worlds is to rebase local changes
you’ve made but haven’t shared yet before you push them in order to clean up
your story, but never rebase anything you’ve pushed somewhere.
Summary
We’ve covered basic branching and merging in Git. You should feel comfortable
creating and switching to new branches, switching between branches and
merging local branches together. You should also be able to share your branches by pushing them to a shared server, working with others on shared branches
and rebasing your branches before they are shared. Next, we’ll cover what
you’ll need to run your own Git repository-hosting server.
CHAPTER 3: Git Branching
124Git on the Server
At this point, you should be able to do most of the day-to-day tasks for which
you’ll be using Git. However, in order to do any collaboration in Git, you’ll need
to have a remote Git repository. Although you can technically push changes to
and pull changes from individuals’ repositories, doing so is discouraged because you can fairly easily confuse what they’re working on if you’re not careful.
Furthermore, you want your collaborators to be able to access the repository
even if your computer is offline – having a more reliable common repository is
often useful. Therefore, the preferred method for collaborating with someone is
to set up an intermediate repository that you both have access to, and push to
and pull from that.
Running a Git server is fairly straightforward. First, you choose which protocols you want your server to communicate with. The first section of this chapter
will cover the available protocols and the pros and cons of each. The next sections will explain some typical setups using those protocols and how to get your
server running with them. Last, we’ll go over a few hosted options, if you don’t
mind hosting your code on someone else’s server and don’t want to go through
the hassle of setting up and maintaining your own server.
If you have no interest in running your own server, you can skip to the last
section of the chapter to see some options for setting up a hosted account and
then move on to the next chapter, where we discuss the various ins and outs of
working in a distributed source control environment.
A remote repository is generally a bare repository – a Git repository that has
no working directory. Because the repository is only used as a collaboration
point, there is no reason to have a snapshot checked out on disk; it’s just the Git
data. In the simplest terms, a bare repository is the contents of your
project’s .git directory and nothing else.
125
4The Protocols
Git can use four major protocols to transfer data: Local, HTTP, Secure Shell
(SSH) and Git. Here we’ll discuss what they are and in what basic circumstances
you would want (or not want) to use them.
Local Protocol
The most basic is the Local protocol, in which the remote repository is in another directory on disk. This is often used if everyone on your team has access to a
shared filesystem such as an NFS mount, or in the less likely case that everyone
logs in to the same computer. The latter wouldn’t be ideal, because all your
code repository instances would reside on the same computer, making a catastrophic loss much more likely.
If you have a shared mounted filesystem, then you can clone, push to, and
pull from a local file-based repository. To clone a repository like this or to add
one as a remote to an existing project, use the path to the repository as the
URL. For example, to clone a local repository, you can run something like this:
$ git clone /opt/git/project.git
Or you can do this:
$ git clone file:///opt/git/project.git
Git operates slightly differently if you explicitly specify file:// at the beginning of the URL. If you just specify the path, Git tries to use hardlinks or directly
copy the files it needs. If you specify file://, Git fires up the processes that it
normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data. The main reason to specify the file://
prefix is if you want a clean copy of the repository with extraneous references or
objects left out – generally after an import from another version-control system
or something similar (see Chapter 10 for maintenance tasks). We’ll use the normal path here because doing so is almost always faster.
To add a local repository to an existing Git project, you can run something
like this:
$ git remote add local_proj /opt/git/project.git
CHAPTER 4: Git on the Server
126Then, you can push to and pull from that remote as though you were doing
so over a network.
THE PROS
The pros of file-based repositories are that they’re simple and they use existing
file permissions and network access. If you already have a shared filesystem to
which your whole team has access, setting up a repository is very easy. You
stick the bare repository copy somewhere everyone has shared access to and
set the read/write permissions as you would for any other shared directory.
We’ll discuss how to export a bare repository copy for this purpose in “Getting
Git on a Server”.
This is also a nice option for quickly grabbing work from someone else’s
working repository. If you and a co-worker are working on the same project and
they want you to check something out, running a command like git pull /
home/john/project is often easier than them pushing to a remote server and
you pulling down.
THE CONS
The cons of this method are that shared access is generally more difficult to set
up and reach from multiple locations than basic network access. If you want to
push from your laptop when you’re at home, you have to mount the remote
disk, which can be difficult and slow compared to network-based access.
It’s important to mention that this isn’t necessarily the fastest option if
you’re using a shared mount of some kind. A local repository is fast only if you
have fast access to the data. A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.
Finally, this protocol does not protect the repository against accidental damage. Every user has full shell access to the “remote” directory, and there is nothing preventing them from changing or removing internal Git files and corrupting the repository.
The HTTP Protocols
Git can communicate over HTTP in two different modes. Prior to Git 1.6.6 there
was only one way it could do this which was very simple and generally readonly. In version 1.6.6 a new, smarter protocol was introduced that involved Git
being able to intelligently negotiate data transfer in a manner similar to how it
does over SSH. In the last few years, this new HTTP protocol has become very
popular since it’s simpler for the user and smarter about how it communicates.
The Protocols
127The newer version is often referred to as the “Smart” HTTP protocol and the
older way as “Dumb” HTTP. We’ll cover the newer “smart” HTTP protocol first.
SMART HTTP
The “smart” HTTP protocol operates very similarly to the SSH or Git protocols
but runs over standard HTTP/S ports and can use various HTTP authentication
mechanisms, meaning it’s often easier on the user than something like SSH,
since you can use things like username/password basic authentication rather
than having to set up SSH keys.
It has probably become the most popular way to use Git now, since it can be
set up to both serve anonymously like the git:// protocol, and can also be
pushed over with authentication and encryption like the SSH protocol. Instead
of having to set up different URLs for these things, you can now use a single URL
for both. If you try to push and the repository requires authentication (which it
normally should), the server can prompt for a username and password. The
same goes for read access.
In fact, for services like GitHub, the URL you use to view the repository online
(for example, “https://github.com/schacon/simplegit”) is the same URL you
can use to clone and, if you have access, push over.
DUMB HTTP
If the server does not respond with a Git HTTP smart service, the Git client will
try to fall back to the simpler “dumb” HTTP protocol. The Dumb protocol expects the bare Git repository to be served like normal files from the web server.
The beauty of the Dumb HTTP protocol is the simplicity of setting it up. Basically, all you have to do is put a bare Git repository under your HTTP document
root and set up a specific post-update hook, and you’re done (See “Git
Hooks”). At that point, anyone who can access the web server under which you
put the repository can also clone your repository. To allow read access to your
repository over HTTP, do something like this:
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
That’s all. The post-update hook that comes with Git by default runs the
appropriate command (git update-server-info) to make HTTP fetching
CHAPTER 4: Git on the Server
128and cloning work properly. This command is run when you push to this repository (over SSH perhaps); then, other people can clone via something like
$ git clone https://example.com/gitproject.git
In this particular case, we’re using the /var/www/htdocs path that is common for Apache setups, but you can use any static web server – just put the
bare repository in its path. The Git data is served as basic static files (see Chapter 10 for details about exactly how it’s served).
Generally you would either choose to run a read/write Smart HTTP server or
simply have the files accessible as read-only in the Dumb manner. It’s rare to
run a mix of the two services.
THE PROS
We’ll concentrate on the pros of the Smart version of the HTTP protocol.
The simplicity of having a single URL for all types of access and having the
server prompt only when authentication is needed makes things very easy for
the end user. Being able to authenticate with a username and password is also
a big advantage over SSH, since users don’t have to generate SSH keys locally
and upload their public key to the server before being able to interact with it.
For less sophisticated users, or users on systems where SSH is less common,
this is a major advantage in usability. It is also a very fast and efficient protocol,
similar to the SSH one.
You can also serve your repositories read-only over HTTPS, which means you
can encrypt the content transfer; or you can go so far as to make the clients use
specific signed SSL certificates.
Another nice thing is that HTTP/S are such commonly used protocols that
corporate firewalls are often set up to allow traffic through these ports.
THE CONS
Git over HTTP/S can be a little more tricky to set up compared to SSH on some
servers. Other than that, there is very little advantage that other protocols have
over the “Smart” HTTP protocol for serving Git.
If you’re using HTTP for authenticated pushing, providing your credentials is
sometimes more complicated than using keys over SSH. There are however several credential caching tools you can use, including Keychain access on OSX
and Credential Manager on Windows, to make this pretty painless. Read “Credential Storage” to see how to set up secure HTTP password caching on your
system.
The Protocols
129The SSH Protocol
A common transport protocol for Git when self-hosting is over SSH. This is because SSH access to servers is already set up in most places – and if it isn’t, it’s
easy to do. SSH is also an authenticated network protocol; and because it’s
ubiquitous, it’s generally easy to set up and use.
To clone a Git repository over SSH, you can specify ssh:// URL like this:
$ git clone ssh://user@server/project.git
Or you can use the shorter scp-like syntax for the SSH protocol:
$ git clone user@server:project.git
You can also not specify a user, and Git assumes the user you’re currently
logged in as.
THE PROS
The pros of using SSH are many. First, SSH is relatively easy to set up – SSH daemons are commonplace, many network admins have experience with them,
and many OS distributions are set up with them or have tools to manage them.
Next, access over SSH is secure – all data transfer is encrypted and authenticated. Last, like the HTTP/S, Git and Local protocols, SSH is efficient, making the
data as compact as possible before transferring it.
THE CONS
The negative aspect of SSH is that you can’t serve anonymous access of your
repository over it. People must have access to your machine over SSH to access
it, even in a read-only capacity, which doesn’t make SSH access conducive to
open source projects. If you’re using it only within your corporate network, SSH
may be the only protocol you need to deal with. If you want to allow anonymous read-only access to your projects and also want to use SSH, you’ll have to
set up SSH for you to push over but something else for others to fetch over.
The Git Protocol
Next is the Git protocol. This is a special daemon that comes packaged with Git;
it listens on a dedicated port (9418) that provides a service similar to the SSH
CHAPTER 4: Git on the Server
130protocol, but with absolutely no authentication. In order for a repository to be
served over the Git protocol, you must create the git-daemon-export-ok file
– the daemon won’t serve a repository without that file in it – but other than
that there is no security. Either the Git repository is available for everyone to
clone or it isn’t. This means that there is generally no pushing over this protocol. You can enable push access; but given the lack of authentication, if you turn
on push access, anyone on the internet who finds your project’s URL could push
to your project. Suffice it to say that this is rare.
THE PROS
The Git protocol is often the fastest network transfer protocol available. If
you’re serving a lot of traffic for a public project or serving a very large project
that doesn’t require user authentication for read access, it’s likely that you’ll
want to set up a Git daemon to serve your project. It uses the same datatransfer mechanism as the SSH protocol but without the encryption and authentication overhead.
THE CONS
The downside of the Git protocol is the lack of authentication. It’s generally undesirable for the Git protocol to be the only access to your project. Generally,
you’ll pair it with SSH or HTTPS access for the few developers who have push
(write) access and have everyone else use git:// for read-only access. It’s also
probably the most difficult protocol to set up. It must run its own daemon,
which requires xinetd configuration or the like, which isn’t always a walk in
the park. It also requires firewall access to port 9418, which isn’t a standard
port that corporate firewalls always allow. Behind big corporate firewalls, this
obscure port is commonly blocked.
Getting Git on a Server
Now we’ll cover setting up a Git service running these protocols on your own
server.
Here we’ll be demonstrating the commands and steps needed to do basic,
simplified installations on a Linux based server, though it’s also possible
to run these services on Mac or Windows servers. Actually setting up a
production server within your infrastructure will certainly entail differences in security measures or operating system tools, but hopefully this
will give you the general idea of what’s involved.
Getting Git on a Server
131In order to initially set up any Git server, you have to export an existing
repository into a new bare repository – a repository that doesn’t contain a
working directory. This is generally straightforward to do. In order to clone your
repository to create a new bare repository, you run the clone command with
the --bare option. By convention, bare repository directories end in .git, like
so:
$ git clone --bare my_project my_project.git
Cloning into bare repository 'my_project.git'...
done.
You should now have a copy of the Git directory data in your
my_project.git directory.
This is roughly equivalent to something like
$ cp -Rf my_project/.git my_project.git
There are a couple of minor differences in the configuration file; but for your
purpose, this is close to the same thing. It takes the Git repository by itself,
without a working directory, and creates a directory specifically for it alone.
Putting the Bare Repository on a Server
Now that you have a bare copy of your repository, all you need to do is put it on
a server and set up your protocols. Let’s say you’ve set up a server called
git.example.com that you have SSH access to, and you want to store all your
Git repositories under the /srv/git directory. Assuming that /srv/git exists
on that server, you can set up your new repository by copying your bare repository over:
$ scp -r my_project.git user@git.example.com:/srv/git
At this point, other users who have SSH access to the same server which has
read-access to the /srv/git directory can clone your repository by running
$ git clone user@git.example.com:/srv/git/my_project.git
CHAPTER 4: Git on the Server
132If a user SSHs into a server and has write access to the /srv/git/
my_project.git directory, they will also automatically have push access.
Git will automatically add group write permissions to a repository properly if
you run the git init command with the --shared option.
$ ssh user@git.example.com
$ cd /srv/git/my_project.git
$ git init --bare --shared
You see how easy it is to take a Git repository, create a bare version, and
place it on a server to which you and your collaborators have SSH access. Now
you’re ready to collaborate on the same project.
It’s important to note that this is literally all you need to do to run a useful
Git server to which several people have access – just add SSH-able accounts on
a server, and stick a bare repository somewhere that all those users have read
and write access to. You’re ready to go – nothing else needed.
In the next few sections, you’ll see how to expand to more sophisticated setups. This discussion will include not having to create user accounts for each
user, adding public read access to repositories, setting up web UIs and more.
However, keep in mind that to collaborate with a couple of people on a private
project, all you need is an SSH server and a bare repository.
Small Setups
If you’re a small outfit or are just trying out Git in your organization and have
only a few developers, things can be simple for you. One of the most complicated aspects of setting up a Git server is user management. If you want some repositories to be read-only to certain users and read/write to others, access and
permissions can be a bit more difficult to arrange.
SSH ACCESS
If you have a server to which all your developers already have SSH access, it’s
generally easiest to set up your first repository there, because you have to do
almost no work (as we covered in the last section). If you want more complex
access control type permissions on your repositories, you can handle them with
the normal filesystem permissions of the operating system your server runs.
If you want to place your repositories on a server that doesn’t have accounts
for everyone on your team whom you want to have write access, then you must
set up SSH access for them. We assume that if you have a server with which to
Getting Git on a Server
133do this, you already have an SSH server installed, and that’s how you’re accessing the server.
There are a few ways you can give access to everyone on your team. The first
is to set up accounts for everybody, which is straightforward but can be cumbersome. You may not want to run adduser and set temporary passwords for
every user.
A second method is to create a single git user on the machine, ask every user
who is to have write access to send you an SSH public key, and add that key to
the ~/.ssh/authorized_keys file of your new git user. At that point, everyone will be able to access that machine via the git user. This doesn’t affect the
commit data in any way – the SSH user you connect as doesn’t affect the commits you’ve recorded.
Another way to do it is to have your SSH server authenticate from an LDAP
server or some other centralized authentication source that you may already
have set up. As long as each user can get shell access on the machine, any SSH
authentication mechanism you can think of should work.
Generating Your SSH Public Key
That being said, many Git servers authenticate using SSH public keys. In order
to provide a public key, each user in your system must generate one if they
don’t already have one. This process is similar across all operating systems.
First, you should check to make sure you don’t already have a key. By default, a
user’s SSH keys are stored in that user’s ~/.ssh directory. You can easily check
to see if you have a key already by going to that directory and listing the contents:
$ cd ~/.ssh
$ ls
authorized_keys2 id_dsa known_hosts
config id_dsa.pub
You’re looking for a pair of files named something like id_dsa or id_rsa
and a matching file with a .pub extension. The .pub file is your public key, and
the other file is your private key. If you don’t have these files (or you don’t even
have a .ssh directory), you can create them by running a program called sshkeygen, which is provided with the SSH package on Linux/Mac systems and
comes with Git for Windows:
CHAPTER 4: Git on the Server
134$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/schacon/.ssh/id_rsa):
Created directory '/home/schacon/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/schacon/.ssh/id_rsa.
Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local
First it confirms where you want to save the key (.ssh/id_rsa), and then it
asks twice for a passphrase, which you can leave empty if you don’t want to
type a password when you use the key.
Now, each user that does this has to send their public key to you or whoever
is administrating the Git server (assuming you’re using an SSH server setup that
requires public keys). All they have to do is copy the contents of the .pub file
and email it. The public keys look something like this:
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@mylaptop.local
For a more in-depth tutorial on creating an SSH key on multiple operating
systems, see the GitHub guide on SSH keys at https://help.github.com/articles/
generating-ssh-keys.
Setting Up the Server
Let’s walk through setting up SSH access on the server side. In this example,
you’ll use the authorized_keys method for authenticating your users. We also assume you’re running a standard Linux distribution like Ubuntu. First, you
create a git user and a .ssh directory for that user.
$ sudo adduser git
$ su git
$ cd
Setting Up the Server
135$ mkdir .ssh && chmod 700 .ssh
$ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys
Next, you need to add some developer SSH public keys to the authorized_keys file for the git user. Let’s assume you have some trusted public
keys and have saved them to temporary files. Again, the public keys look something like this:
$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair
You just append them to the git user’s authorized_keys file in its .ssh
directory:
$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys
Now, you can set up an empty repository for them by running git init
with the --bare option, which initializes the repository without a working directory:
$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /opt/git/project.git/
Then, John, Josie, or Jessica can push the first version of their project into
that repository by adding it as a remote and pushing up a branch. Note that
someone must shell onto the machine and create a bare repository every time
you want to add a project. Let’s use gitserver as the hostname of the server
on which you’ve set up your git user and repository. If you’re running it internally, and you set up DNS for gitserver to point to that server, then you can
use the commands pretty much as is (assuming that myproject is an existing
project with files in it):
CHAPTER 4: Git on the Server
136# on John's computer
$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master
At this point, the others can clone it down and push changes back up just as
easily:
$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master
With this method, you can quickly get a read/write Git server up and running
for a handful of developers.
You should note that currently all these users can also log into the server
and get a shell as the git user. If you want to restrict that, you will have to
change the shell to something else in the passwd file.
You can easily restrict the git user to only doing Git activities with a limited
shell tool called git-shell that comes with Git. If you set this as your git
user’s login shell, then the git user can’t have normal shell access to your server. To use this, specify git-shell instead of bash or csh for your user’s login
shell. To do so, you must first add git-shell to /etc/shells if it’s not already
there:
$ cat /etc/shells # see if `git-shell` is already in there. If not...
$ which git-shell # make sure git-shell is installed on your system.
$ sudo vim /etc/shells # and add the path to git-shell from last command
Now you can edit the shell for a user using chsh <username>:
$ sudo chsh git # and enter the path to git-shell, usually: /usr/bin/git-shell
Now, the git user can only use the SSH connection to push and pull Git repositories and can’t shell onto the machine. If you try, you’ll see a login rejection like this:
Setting Up the Server
137$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.
Now Git network commands will still work just fine but the users won’t be
able to get a shell. As the output states, you can also set up a directory in the
git user’s home directory that customizes the git-shell command a bit. For
instance, you can restrict the Git commands that the server will accept or you
can customize the message that users see if they try to SSH in like that. Run git
help shell for more information on customizing the shell.
Git Daemon
Next we’ll set up a daemon serving repositories over the “Git” protocol. This is
common choice for fast, unauthenticated access to your Git data. Remember
that since it’s not an authenticated service, anything you serve over this protocol is public within its network.
If you’re running this on a server outside your firewall, it should only be used
for projects that are publicly visible to the world. If the server you’re running it
on is inside your firewall, you might use it for projects that a large number of
people or computers (continuous integration or build servers) have read-only
access to, when you don’t want to have to add an SSH key for each.
In any case, the Git protocol is relatively easy to set up. Basically, you need to
run this command in a daemonized manner:
$ git daemon --reuseaddr --base-path=/opt/git/ /opt/git/
--reuseaddr allows the server to restart without waiting for old connections to time out, the --base-path option allows people to clone projects
without specifying the entire path, and the path at the end tells the Git daemon
where to look for repositories to export. If you’re running a firewall, you’ll also
need to punch a hole in it at port 9418 on the box you’re setting this up on.
You can daemonize this process a number of ways, depending on the operating system you’re running. On an Ubuntu machine, you can use an Upstart
script. So, in the following file
/etc/init/local-git-daemon.conf
CHAPTER 4: Git on the Server
138you put this script:
start on startup
stop on shutdown
exec /usr/bin/git daemon \
--user=git --group=git \
--reuseaddr \
--base-path=/opt/git/ \
/opt/git/
respawn
For security reasons, it is strongly encouraged to have this daemon run as a
user with read-only permissions to the repositories – you can easily do this by
creating a new user git-ro and running the daemon as them. For the sake of
simplicity we’ll simply run it as the same git user that git-shell is running as.
When you restart your machine, your Git daemon will start automatically
and respawn if it goes down. To get it running without having to reboot, you
can run this:
$ initctl start local-git-daemon
On other systems, you may want to use xinetd, a script in your sysvinit
system, or something else – as long as you get that command daemonized and
watched somehow.
Next, you have to tell Git which repositories to allow unauthenticated Git
server-based access to. You can do this in each repository by creating a file
named git-daemon-export-ok.
$ cd /path/to/project.git
$ touch git-daemon-export-ok
The presence of that file tells Git that it’s OK to serve this project without authentication.
Smart HTTP
We now have authenticated access though SSH and unauthenticated access
through git://, but there is also a protocol that can do both at the same time.
Setting up Smart HTTP is basically just enabling a CGI script that is provided
with Git called git-http-backend on the server. This CGI will read the path
Smart HTTP
139and headers sent by a git fetch or git push to an HTTP URL and determine
if the client can communicate over HTTP (which is true for any client since version 1.6.6). If the CGI sees that the client is smart, it will communicate smartly
with it, otherwise it will fall back to the dumb behavior (so it is backward compatible for reads with older clients).
Let’s walk through a very basic setup. We’ll set this up with Apache as the
CGI server. If you don’t have Apache setup, you can do so on a Linux box with
something like this:
$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env rewrite
This also enables the mod_cgi, mod_alias, mod_env, and mod_rewrite
modules, which are all needed for this to work properly.
You’ll also need to set the Unix user group of the /opt/git directories to
www-data so your web server can read- and write-access the repositories, because the Apache instance running the CGI script will (by default) be running as
that user:
$ chgrp -R www-data /opt/git
Next we need to add some things to the Apache configuration to run the
git-http-backend as the handler for anything coming into the /git path of
your web server.
SetEnv GIT_PROJECT_ROOT /opt/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
If you leave out GIT_HTTP_EXPORT_ALL environment variable, then Git will
only serve to unauthenticated clients the repositories with the git-daemonexport-ok file in them, just like the Git daemon did.
Finally you’ll want to tell Apache to allow requests to git-http-backend
and make writes be authenticated somehow, possibly with an Auth block like
this:
RewriteEngine On
RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]
RewriteCond %{REQUEST_URI} /git-receive-pack$
CHAPTER 4: Git on the Server
140RewriteRule ^/git/ - [E=AUTHREQUIRED]
<Files "git-http-backend">
AuthType Basic
AuthName "Git Access"
AuthUserFile /opt/git/.htpasswd
Require valid-user
Order deny,allow
Deny from env=AUTHREQUIRED
Satisfy any
</Files>
That will require you to create a .htpasswd file containing the passwords of
all the valid users. Here is an example of adding a “schacon” user to the file:
$ htpasswd -c /opt/git/.htpasswd schacon
There are tons of ways to have Apache authenticate users, you’ll have to
choose and implement one of them. This is just the simplest example we could
come up with. You’ll also almost certainly want to set this up over SSL so all this
data is encrypted.
We don’t want to go too far down the rabbit hole of Apache configuration
specifics, since you could well be using a different server or have different authentication needs. The idea is that Git comes with a CGI called git-httpbackend that when invoked will do all the negotiation to send and receive data
over HTTP. It does not implement any authentication itself, but that can easily
be controlled at the layer of the web server that invokes it. You can do this with
nearly any CGI-capable web server, so go with the one that you know best.
For more information on configuring authentication in Apache, check
out the Apache docs here: http://httpd.apache.org/docs/current/howto/
auth.html
GitWeb
Now that you have basic read/write and read-only access to your project, you
may want to set up a simple web-based visualizer. Git comes with a CGI script
called GitWeb that is sometimes used for this.
GitWeb
141FIGURE 4-1
The GitWeb webbased user interface.
If you want to check out what GitWeb would look like for your project, Git
comes with a command to fire up a temporary instance if you have a lightweight server on your system like lighttpd or webrick. On Linux machines,
lighttpd is often installed, so you may be able to get it to run by typing git
instaweb in your project directory. If you’re running a Mac, Leopard comes
preinstalled with Ruby, so webrick may be your best bet. To start instaweb
with a non-lighttpd handler, you can run it with the --httpd option.
$ git instaweb --httpd=webrick
[2009-02-21 10:02:21] INFO WEBrick 1.3.1
[2009-02-21 10:02:21] INFO ruby 1.8.6 (2008-03-03) [universal-darwin9.0]
That starts up an HTTPD server on port 1234 and then automatically starts a
web browser that opens on that page. It’s pretty easy on your part. When you’re
done and want to shut down the server, you can run the same command with
the --stop option:
$ git instaweb --httpd=webrick --stop
CHAPTER 4: Git on the Server
142If you want to run the web interface on a server all the time for your team or
for an open source project you’re hosting, you’ll need to set up the CGI script to
be served by your normal web server. Some Linux distributions have a gitweb
package that you may be able to install via apt or yum, so you may want to try
that first. We’ll walk through installing GitWeb manually very quickly. First, you
need to get the Git source code, which GitWeb comes with, and generate the
custom CGI script:
$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT="/opt/git" prefix=/usr gitweb
SUBDIR gitweb
SUBDIR ../
make[2]: `GIT-VERSION-FILE' is up to date.
GEN gitweb.cgi
GEN static/gitweb.js
$ sudo cp -Rf gitweb /var/www/
Notice that you have to tell the command where to find your Git repositories
with the GITWEB_PROJECTROOT variable. Now, you need to make Apache use
CGI for that script, for which you can add a VirtualHost:
<VirtualHost *:80>
ServerName gitserver
DocumentRoot /var/www/gitweb
<Directory /var/www/gitweb>
Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
AllowOverride All
order allow,deny
Allow from all
AddHandler cgi-script cgi
DirectoryIndex gitweb.cgi
</Directory>
</VirtualHost>
Again, GitWeb can be served with any CGI or Perl capable web server; if you
prefer to use something else, it shouldn’t be difficult to set up. At this point, you
should be able to visit http://gitserver/ to view your repositories online.
GitWeb
143FIGURE 4-2
The Bitnami GitLab
virtual machine
login screen.
GitLab
GitWeb is pretty simplistic though. If you’re looking for a more modern, fully
featured Git server, there are some several open source solutions out there that
you can install instead. As GitLab is one of the more popular ones, we’ll cover
installing and using it as an example. This is a bit more complex than the GitWeb option and likely requires more maintenance, but it is a much more fully
featured option.
Installation
GitLab is a database-backed web application, so its installation is a bit more involved than some other git servers. Fortunately, this process is very welldocumented and supported.
There are a few methods you can pursue to install GitLab. To get something
up and running quickly, you can download a virtual machine image or a oneclick installer from https://bitnami.com/stack/gitlab, and tweak the configuration to match your particular environment. One nice touch Bitnami has included is the login screen (accessed by typing alt-→); it tells you the IP address and
default username and password for the installed GitLab.
For anything else, follow the guidance in the GitLab Community Edition readme, which can be found at https://gitlab.com/gitlab-org/gitlab-ce/tree/
master. There you’ll find assistance for installing GitLab using Chef recipes, a
CHAPTER 4: Git on the Server
144FIGURE 4-3
The “Admin area”
item in the GitLab
menu.
virtual machine on Digital Ocean, and RPM and DEB packages (which, as of this
writing, are in beta). There’s also “unofficial” guidance on getting GitLab running with non-standard operating systems and databases, a fully-manual installation script, and many other topics.
Administration
GitLab’s administration interface is accessed over the web. Simply point your
browser to the hostname or IP address where GitLab is installed, and log in as
an admin user. The default username is admin@local.host, and the default
password is 5iveL!fe (which you will be prompted to change as soon as you
enter it). Once logged in, click the “Admin area” icon in the menu at the top
right.
USERS
Users in GitLab are accounts that correspond to people. User accounts don’t
have a lot of complexity; mainly it’s a collection of personal information attached to login data. Each user account comes with a namespace, which is a logical
grouping of projects that belong to that user. If the user jane had a project
named project, that project’s url would be http://server/jane/project.
GitLab
145FIGURE 4-4
The GitLab user
administration
screen.
Removing a user can be done in two ways. “Blocking” a user prevents them
from logging into the GitLab instance, but all of the data under that user’s
namespace will be preserved, and commits signed with that user’s email address will still link back to their profile.
“Destroying” a user, on the other hand, completely removes them from the
database and filesystem. All projects and data in their namespace is removed,
and any groups they own will also be removed. This is obviously a much more
permanent and destructive action, and its uses are rare.
GROUPS
A GitLab group is an assemblage of projects, along with data about how users
can access those projects. Each group has a project namespace (the same way
that users do), so if the group training has a project materials, its url would
be http://server/training/materials.
CHAPTER 4: Git on the Server
146FIGURE 4-5
The GitLab group
administration
screen.
Each group is associated with a number of users, each of which has a level of
permissions for the group’s projects and the group itself. These range from
“Guest” (issues and chat only) to “Owner” (full control of the group, its members, and its projects). The types of permissions are too numerous to list here,
but GitLab has a helpful link on the administration screen.
PROJECTS
A GitLab project roughly corresponds to a single git repository. Every project
belongs to a single namespace, either a user or a group. If the project belongs
to a user, the owner of the project has direct control over who has access to the
project; if the project belongs to a group, the group’s user-level permissions will
also take effect.
Every project also has a visibility level, which controls who has read access
to that project’s pages and repository. If a project is Private, the project’s owner
must explicitly grant access to specific users. An Internal project is visible to any
logged-in user, and a Public project is visible to anyone. Note that this controls
both git “fetch” access as well as access to the web UI for that project.
HOOKS
GitLab includes support for hooks, both at a project or system level. For either
of these, the GitLab server will perform an HTTP POST with some descriptive
JSON whenever relevant events occur. This is a great way to connect your git
repositories and GitLab instance to the rest of your development automation,
such as CI servers, chat rooms, or deployment tools.
GitLab
147Basic Usage
The first thing you’ll want to do with GitLab is create a new project. This is accomplished by clicking the “+” icon on the toolbar. You’ll be asked for the
project’s name, which namespace it should belong to, and what its visibility level should be. Most of what you specify here isn’t permanent, and can be readjusted later through the settings interface. Click “Create Project”, and you’re
done.
Once the project exists, you’ll probably want to connect it with a local Git
repository. Each project is accessible over HTTPS or SSH, either of which can be
used to configure a Git remote. The URLs are visible at the top of the project’s
home page. For an existing local repository, this command will create a remote
named gitlab to the hosted location:
$ git remote add gitlab https://server/namespace/project.git
If you don’t have a local copy of the repository, you can simply do this:
$ git clone https://server/namespace/project.git
The web UI provides access to several useful views of the repository itself.
Each project’s home page shows recent activity, and links along the top will
lead you to views of the project’s files and commit log.
Working Together
The simplest way of working together on a GitLab project is by giving another
user direct push access to the git repository. You can add a user to a project by
going to the “Members” section of that project’s settings, and associating the
new user with an access level (the different access levels are discussed a bit in
“Groups”). By giving a user an access level of “Developer” or above, that user
can push commits and branches directly to the repository with impunity.
Another, more decoupled way of collaboration is by using merge requests.
This feature enables any user that can see a project to contribute to it in a controlled way. Users with direct access can simply create a branch, push commits
to it, and open a merge request from their branch back into master or any other branch. Users who don’t have push permissions for a repository can “fork” it
(create their own copy), push commits to that copy, and open a merge request
from their fork back to the main project. This model allows the owner to be in
CHAPTER 4: Git on the Server
148full control of what goes into the repository and when, while allowing contributions from untrusted users.
Merge requests and issues are the main units of long-lived discussion in GitLab. Each merge request allows a line-by-line discussion of the proposed
change (which supports a lightweight kind of code review), as well as a general
overall discussion thread. Both can be assigned to users, or organized into milestones.
This section is focused mainly on the Git-related features of GitLab, but as a
mature project, it provides many other features to help your team work together, such as project wikis and system maintenance tools. One benefit to GitLab is
that, once the server is set up and running, you’ll rarely need to tweak a configuration file or access the server via SSH; most administration and general usage
can be accomplished through the in-browser interface.
Third Party Hosted Options
If you don’t want to go through all of the work involved in setting up your own
Git server, you have several options for hosting your Git projects on an external
dedicated hosting site. Doing so offers a number of advantages: a hosting site is
generally quick to set up and easy to start projects on, and no server maintenance or monitoring is involved. Even if you set up and run your own server internally, you may still want to use a public hosting site for your open source
code – it’s generally easier for the open source community to find and help you
with.
These days, you have a huge number of hosting options to choose from,
each with different advantages and disadvantages. To see an up-to-date list,
check out the GitHosting page on the main Git wiki at https://
git.wiki.kernel.org/index.php/GitHosting
We’ll cover using GitHub in detail in Chapter 6, as it is the largest Git host
out there and you may need to interact with projects hosted on it in any case,
but there are dozens more to choose from should you not want to set up your
own Git server.
Summary
You have several options to get a remote Git repository up and running so that
you can collaborate with others or share your work.
Running your own server gives you a lot of control and allows you to run the
server within your own firewall, but such a server generally requires a fair
amount of your time to set up and maintain. If you place your data on a hosted
Third Party Hosted Options
149server, it’s easy to set up and maintain; however, you have to be able to keep
your code on someone else’s servers, and some organizations don’t allow that.
It should be fairly straightforward to determine which solution or combination of solutions is appropriate for you and your organization.
CHAPTER 4: Git on the Server
150Distributed Git
Now that you have a remote Git repository set up as a point for all the developers to share their code, and you’re familiar with basic Git commands in a local
workflow, you’ll look at how to utilize some of the distributed workflows that
Git affords you.
In this chapter, you’ll see how to work with Git in a distributed environment
as a contributor and an integrator. That is, you’ll learn how to contribute code
successfully to a project and make it as easy on you and the project maintainer
as possible, and also how to maintain a project successfully with a number of
developers contributing.
Distributed Workflows
Unlike Centralized Version Control Systems (CVCSs), the distributed nature of
Git allows you to be far more flexible in how developers collaborate on projects.
In centralized systems, every developer is a node working more or less equally
on a central hub. In Git, however, every developer is potentially both a node
and a hub – that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and
which they can contribute to. This opens a vast range of workflow possibilities
for your project and/or your team, so we’ll cover a few common paradigms that
take advantage of this flexibility. We’ll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and
match features from each.
Centralized Workflow
In centralized systems, there is generally a single collaboration model–the centralized workflow. One central hub, or repository, can accept code, and everyone synchronizes their work to it. A number of developers are nodes – consumers of that hub – and synchronize to that one place.
151
5FIGURE 5-1
Centralized
workflow.
This means that if two developers clone from the hub and both make
changes, the first developer to push their changes back up can do so with no
problems. The second developer must merge in the first one’s work before
pushing changes up, so as not to overwrite the first developer’s changes. This
concept is as true in Git as it is in Subversion (or any CVCS), and this model
works perfectly well in Git.
If you are already comfortable with a centralized workflow in your company
or team, you can easily continue using that workflow with Git. Simply set up a
single repository, and give everyone on your team push access; Git won’t let
users overwrite each other. Say John and Jessica both start working at the
same time. John finishes his change and pushes it to the server. Then Jessica
tries to push her changes, but the server rejects them. She is told that she’s trying to push non-fast-forward changes and that she won’t be able to do so until
she fetches and merges. This workflow is attractive to a lot of people because
it’s a paradigm that many are familiar and comfortable with.
This is also not limited to small teams. With Git’s branching model, it’s possible for hundreds of developers to successfully work on a single project through
dozens of branches simultaneously.
Integration-Manager Workflow
Because Git allows you to have multiple remote repositories, it’s possible to
have a workflow where each developer has write access to their own public
repository and read access to everyone else’s. This scenario often includes a
canonical repository that represents the “official” project. To contribute to that
project, you create your own public clone of the project and push your changes
to it. Then, you can send a request to the maintainer of the main project to pull
in your changes. The maintainer can then add your repository as a remote, test
CHAPTER 5: Distributed Git
152FIGURE 5-2
Integrationmanager workflow.
your changes locally, merge them into their branch, and push back to their
repository. The process works as follows (see Figure 5-2):
1. The project maintainer pushes to their public repository.
2. A contributor clones that repository and makes changes.
3. The contributor pushes to their own public copy.
4. The contributor sends the maintainer an email asking them to pull
changes.
5. The maintainer adds the contributor’s repo as a remote and merges locally.
6. The maintainer pushes merged changes to the main repository.
This is a very common workflow with hub-based tools like GitHub or GitLab,
where it’s easy to fork a project and push your changes into your fork for everyone to see. One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes
at any time. Contributors don’t have to wait for the project to incorporate their
changes – each party can work at their own pace.
Dictator and Lieutenants Workflow
This is a variant of a multiple-repository workflow. It’s generally used by huge
projects with hundreds of collaborators; one famous example is the Linux kernel. Various integration managers are in charge of certain parts of the repository; they’re called lieutenants. All the lieutenants have one integration manager
known as the benevolent dictator. The benevolent dictator’s repository serves
as the reference repository from which all the collaborators need to pull. The
process works like this (see Figure 5-3):
Distributed Workflows
153FIGURE 5-3
Benevolent dictator
workflow.
1. Regular developers work on their topic branch and rebase their work on
top of master. The master branch is that of the dictator.
2. Lieutenants merge the developers’ topic branches into their master
branch.
3. The dictator merges the lieutenants’ master branches into the dictator’s
master branch.
4. The dictator pushes their master to the reference repository so the other
developers can rebase on it.
This kind of workflow isn’t common, but can be useful in very big projects, or
in highly hierarchical environments. It allows the project leader (the dictator) to
delegate much of the work and collect large subsets of code at multiple points
before integrating them.
Workflows Summary
These are some commonly used workflows that are possible with a distributed
system like Git, but you can see that many variations are possible to suit your
particular real-world workflow. Now that you can (hopefully) determine which
workflow combination may work for you, we’ll cover some more specific examples of how to accomplish the main roles that make up the different flows. In
the next section, you’ll learn about a few common patterns for contributing to a
project.
CHAPTER 5: Distributed Git
154Contributing to a Project
The main difficulty with describing how to contribute to a project is that there
are a huge number of variations on how it’s done. Because Git is very flexible,
people can and do work together in many ways, and it’s problematic to describe how you should contribute – every project is a bit different. Some of the
variables involved are active contributor count, chosen workflow, your commit
access, and possibly the external contribution method.
The first variable is active contributor count – how many users are actively
contributing code to this project, and how often? In many instances, you’ll have
two or three developers with a few commits a day, or possibly less for somewhat dormant projects. For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day. This is important because with more and more developers, you
run into more issues with making sure your code applies cleanly or can be easily merged. Changes you submit may be rendered obsolete or severely broken
by work that is merged in while you were working or while your changes were
waiting to be approved or applied. How can you keep your code consistently up
to date and your commits valid?
The next variable is the workflow in use for the project. Is it centralized, with
each developer having equal write access to the main codeline? Does the
project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved? Are you involved in that process? Is a lieutenant system in place, and do you have to submit your work to
them first?
The next issue is your commit access. The workflow required in order to contribute to a project is much different if you have write access to the project than
if you don’t. If you don’t have write access, how does the project prefer to accept contributed work? Does it even have a policy? How much work are you
contributing at a time? How often do you contribute?
All these questions can affect how you contribute effectively to a project and
what workflows are preferred or available to you. We’ll cover aspects of each of
these in a series of use cases, moving from simple to more complex; you should
be able to construct the specific workflows you need in practice from these examples.
Commit Guidelines
Before we start looking at the specific use cases, here’s a quick note about commit messages. Having a good guideline for creating commits and sticking to it
makes working with Git and collaborating with others a lot easier. The Git
Contributing to a Project
155FIGURE 5-4
Output of git diff
--check.
project provides a document that lays out a number of good tips for creating
commits from which to submit patches – you can read it in the Git source code
in the Documentation/SubmittingPatches file.
First, you don’t want to submit any whitespace errors. Git provides an easy
way to check for this – before you commit, run git diff --check, which
identifies possible whitespace errors and lists them for you.
If you run that command before committing, you can tell if you’re about to
commit whitespace issues that may annoy other developers.
Next, try to make each commit a logically separate changeset. If you can, try
to make your changes digestible – don’t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
Even if you don’t commit during the weekend, use the staging area on Monday
to split your work into at least one commit per issue, with a useful message per
commit. If some of the changes modify the same file, try to use git add --
patch to partially stage files (covered in detail in “Interactive Staging”). The
project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make
things easier on your fellow developers when they have to review your changes.
This approach also makes it easier to pull out or revert one of the changesets if
you need to later. “Rewriting History” describes a number of useful Git tricks
for rewriting history and interactively staging files – use these tools to help craft
a clean and understandable history before sending the work to someone else.
The last thing to keep in mind is the commit message. Getting in the habit of
creating quality commit messages makes using and collaborating with Git a lot
easier. As a general rule, your messages should start with a single line that’s no
CHAPTER 5: Distributed Git
156more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation. The Git project
requires that the more detailed explanation include your motivation for the
change and contrast its implementation with previous behavior – this is a good
guideline to follow. It’s also a good idea to use the imperative present tense in
these messages. In other words, use commands. Instead of “I added tests for”
or “Adding tests for,” use “Add tests for.” Here is a template originally written by
Tim Pope:
Short (50 chars or less) summary of changes
More detailed explanatory text, if necessary. Wrap it to
about 72 characters or so. In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body. The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.
Further paragraphs come after blank lines.
- Bullet points are okay, too
- Typically a hyphen or asterisk is used for the bullet,
preceded by a single space, with blank lines in
between, but conventions vary here
If all your commit messages look like this, things will be a lot easier for you
and the developers you work with. The Git project has well-formatted commit
messages – try running git log --no-merges there to see what a nicely formatted project-commit history looks like.
In the following examples, and throughout most of this book, for the sake of
brevity this book doesn’t have nicely-formatted messages like this; instead, we
use the -m option to git commit. Do as we say, not as we do.
Private Small Team
The simplest setup you’re likely to encounter is a private project with one or
two other developers. “Private,” in this context, means closed-source – not accessible to the outside world. You and the other developers all have push access to the repository.
In this environment, you can follow a workflow similar to what you might do
when using Subversion or another centralized system. You still get the advantages of things like offline committing and vastly simpler branching and mergContributing to a Project
157ing, but the workflow can be very similar; the main difference is that merges
happen client-side rather than on the server at commit time. Let’s see what it
might look like when two developers start to work together with a shared
repository. The first developer, John, clones the repository, makes a change,
and commits locally. (The protocol messages have been replaced with ... in
these examples to shorten them somewhat.)
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
1 files changed, 1 insertions(+), 1 deletions(-)
The second developer, Jessica, does the same thing – clones the repository
and commits a change:
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
1 files changed, 1 insertions(+), 0 deletions(-)
Now, Jessica pushes her work up to the server:
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
1edee6b..fbff5bc master -> master
John tries to push his change up, too:
# John's Machine
$ git push origin master
To john@githost:simplegit.git
CHAPTER 5: Distributed Git
158FIGURE 5-5
John’s divergent
history.
! [rejected] master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
John isn’t allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you’re used to Subversion, because you’ll notice that the two developers didn’t edit the same file. Although
Subversion automatically does such a merge on the server if different files are
edited, in Git you must merge the commits locally. John has to fetch Jessica’s
changes and merge them in before he will be allowed to push:
$ git fetch origin
...
From john@githost:simplegit
+ 049d078...fbff5bc master -> origin/master
At this point, John’s local repository looks something like this:
John has a reference to the changes Jessica pushed up, but he has to merge
them into his own work before he is allowed to push:
$ git merge origin/master
Merge made by recursive.
Contributing to a Project
159FIGURE 5-6
John’s repository
after merging
origin/master.
FIGURE 5-7
John’s history after
pushing to the
origin server.
TODO | 1 +
1 files changed, 1 insertions(+), 0 deletions(-)
The merge goes smoothly – John’s commit history now looks like this:
Now, John can test his code to make sure it still works properly, and then he
can push his new merged work up to the server:
$ git push origin master
...
To john@githost:simplegit.git
fbff5bc..72bbc59 master -> master
Finally, John’s commit history looks like this:
CHAPTER 5: Distributed Git
160FIGURE 5-8
Jessica’s topic
branch.
FIGURE 5-9
Jessica’s history
after fetching John’s
changes.
In the meantime, Jessica has been working on a topic branch. She’s created
a topic branch called issue54 and done three commits on that branch. She
hasn’t fetched John’s changes yet, so her commit history looks like this:
Jessica wants to sync up with John, so she fetches:
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
fbff5bc..72bbc59 master -> origin/master
That pulls down the work John has pushed up in the meantime. Jessica’s
history now looks like this:
Jessica thinks her topic branch is ready, but she wants to know what she has
to merge into her work so that she can push. She runs git log to find out:
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Contributing to a Project
161Date: Fri May 29 16:01:27 2009 -0700
removed invalid default value
The issue54..origin/master syntax is a log filter that asks Git to only
show the list of commits that are on the latter branch (in this case origin/
master) that are not on the first branch (in this case issue54). We’ll go over
this syntax in detail in “Commit Ranges”.
For now, we can see from the output that there is a single commit that John
has made that Jessica has not merged in. If she merges origin/master, that is
the single commit that will modify her local work.
Now, Jessica can merge her topic work into her master branch, merge John’s
work (origin/master) into her master branch, and then push back to the
server again. First, she switches back to her master branch to integrate all this
work:
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
She can merge either origin/master or issue54 first – they’re both upstream, so the order doesn’t matter. The end snapshot should be identical no
matter which order she chooses; only the history will be slightly different. She
chooses to merge in issue54 first:
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
README | 1 +
lib/simplegit.rb | 6 +++++-
2 files changed, 6 insertions(+), 1 deletions(-)
No problems occur; as you can see it was a simple fast-forward. Now Jessica
merges in John’s work (origin/master):
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
lib/simplegit.rb | 2 +-
1 files changed, 1 insertions(+), 1 deletions(-)
CHAPTER 5: Distributed Git
162FIGURE 5-10
Jessica’s history
after merging John’s
changes.
FIGURE 5-11
Jessica’s history
after pushing all
changes back to the
server.
Everything merges cleanly, and Jessica’s history looks like this:
Now origin/master is reachable from Jessica’s master branch, so she
should be able to successfully push (assuming John hasn’t pushed again in the
meantime):
$ git push origin master
...
To jessica@githost:simplegit.git
72bbc59..8059c15 master -> master
Each developer has committed a few times and merged each other’s work
successfully.
That is one of the simplest workflows. You work for a while, generally in a
topic branch, and merge into your master branch when it’s ready to be integrated. When you want to share that work, you fetch and merge your master from
origin/master if it has changed, and finally push to the master branch on the
server. The general sequence is something like this:
Contributing to a Project
163FIGURE 5-12
General sequence of
events for a simple
multiple-developer
Git workflow.
Private Managed Team
In this next scenario, you’ll look at contributor roles in a larger private group.
You’ll learn how to work in an environment where small groups collaborate on
features and then those team-based contributions are integrated by another
party.
Let’s say that John and Jessica are working together on one feature, while
Jessica and Josie are working on a second. In this case, the company is using a
CHAPTER 5: Distributed Git
164type of integration-manager workflow where the work of the individual groups
is integrated only by certain engineers, and the master branch of the main repo
can be updated only by those engineers. In this scenario, all work is done in
team-based branches and pulled together by the integrators later.
Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment. Assuming she
already has her repository cloned, she decides to work on featureA first. She
creates a new branch for the feature and does some work on it there:
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
1 files changed, 1 insertions(+), 1 deletions(-)
At this point, she needs to share her work with John, so she pushes her featureA branch commits up to the server. Jessica doesn’t have push access to
the master branch – only the integrators do – so she has to push to another
branch in order to collaborate with John:
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
* [new branch] featureA -> featureA
Jessica emails John to tell him that she’s pushed some work into a branch
named featureA and he can look at it now. While she waits for feedback from
John, Jessica decides to start working on featureB with Josie. To begin, she
starts a new feature branch, basing it off the server’s master branch:
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
Now, Jessica makes a couple of commits on the featureB branch:
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
Contributing to a Project
165FIGURE 5-13
Jessica’s initial
commit history.
[featureB e5b0fdc] made the ls-tree function recursive
1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
1 files changed, 5 insertions(+), 0 deletions(-)
Jessica’s repository looks like this:
She’s ready to push up her work, but gets an email from Josie that a branch
with some initial work on it was already pushed to the server as featureBee.
Jessica first needs to merge those changes in with her own before she can push
to the server. She can then fetch Josie’s changes down with git fetch:
$ git fetch origin
...
From jessica@githost:simplegit
* [new branch] featureBee -> origin/featureBee
Jessica can now merge this into the work she did with git merge:
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
lib/simplegit.rb | 4 ++++
1 files changed, 4 insertions(+), 0 deletions(-)
CHAPTER 5: Distributed Git
166There is a bit of a problem – she needs to push the merged work in her featureB branch to the featureBee branch on the server. She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to
the git push command:
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
fba9af8..cd685d1 featureB -> featureBee
This is called a refspec. See “The Refspec” for a more detailed discussion of
Git refspecs and different things you can do with them. Also notice the -u flag;
this is short for --set-upstream, which configures the branches for easier
pushing and pulling later.
Next, John emails Jessica to say he’s pushed some changes to the featureA
branch and asks her to verify them. She runs a git fetch to pull down those
changes:
$ git fetch origin
...
From jessica@githost:simplegit
3300904..aad881d featureA -> origin/featureA
Then, she can see what has been changed with git log:
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date: Fri May 29 19:57:33 2009 -0700
changed log output to 30 from 25
Finally, she merges John’s work into her own featureA branch:
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
lib/simplegit.rb | 10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
Contributing to a Project
167FIGURE 5-14
Jessica’s history
after committing on
a feature branch.
Jessica wants to tweak something, so she commits again and then pushes
this back up to the server:
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
3300904..774b3ed featureA -> featureA
Jessica’s commit history now looks something like this:
Jessica, Josie, and John inform the integrators that the featureA and featureBee branches on the server are ready for integration into the mainline. Affterthe integrators merge these branches into the mainline, a fetch will bring
down the new merge commit, making the history look like this:
CHAPTER 5: Distributed Git
168FIGURE 5-15
Jessica’s history
after merging both
her topic branches.
Many groups switch to Git because of this ability to have multiple teams
working in parallel, merging the different lines of work late in the process. The
ability of smaller subgroups of a team to collaborate via remote branches
without necessarily having to involve or impede the entire team is a huge benefit of Git. The sequence for the workflow you saw here is something like this:
Contributing to a Project
169FIGURE 5-16
Basic sequence of
this managed-team
workflow.
Forked Public Project
Contributing to public projects is a bit different. Because you don’t have the
permissions to directly update branches on the project, you have to get the
work to the maintainers some other way. This first example describes contributing via forking on Git hosts that support easy forking. Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others),
and many project maintainers expect this style of contribution. The next section deals with projects that prefer to accept contributed patches via email.
First, you’ll probably want to clone the main repository, create a topic
branch for the patch or patch series you’re planning to contribute, and do your
work there. The sequence looks basically like this:
CHAPTER 5: Distributed Git
170$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
You may want to use rebase -i to squash your work down to a single
commit, or rearrange the work in the commits to make the patch easier
for the maintainer to review – see “Rewriting History” for more information about interactive rebasing.
When your branch work is finished and you’re ready to contribute it back to
the maintainers, go to the original project page and click the “Fork” button, creating your own writable fork of the project. You then need to add in this new
repository URL as a second remote, in this case named myfork:
$ git remote add myfork (url)
Then you need to push your work up to it. It’s easiest to push the topic
branch you’re working on up to your repository, rather than merging into your
master branch and pushing that up. The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch. If the
maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it
back via pulling from their repository anyhow:
$ git push -u myfork featureA
When your work has been pushed up to your fork, you need to notify the
maintainer. This is often called a pull request, and you can either generate it via
the website – GitHub has its own Pull Request mechanism that we’ll go over in
Chapter 6 – or you can run the git request-pull command and email the
output to the project maintainer manually.
The request-pull command takes the base branch into which you want
your topic branch pulled and the Git repository URL you want them to pull
from, and outputs a summary of all the changes you’re asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she’s done two
commits on the topic branch she just pushed up, she can run this:
Contributing to a Project
171$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
John Smith (1):
added a new function
are available in the git repository at:
git://githost/simplegit.git featureA
Jessica Smith (2):
add limit to log function
change log output to 30 from 25
lib/simplegit.rb | 10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
The output can be sent to the maintainer – it tells them where the work was
branched from, summarizes the commits, and tells where to pull this work
from.
On a project for which you’re not the maintainer, it’s generally easier to have
a branch like master always track origin/master and to do your work in topic branches that you can easily discard if they’re rejected. Having work themes
isolated into topic branches also makes it easier for you to rebase your work if
the tip of the main repository has moved in the meantime and your commits no
longer apply cleanly. For example, if you want to submit a second topic of work
to the project, don’t continue working on the topic branch you just pushed up –
start over from the main repository’s master branch:
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
Now, each of your topics is contained within a silo – similar to a patch queue
– that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:
CHAPTER 5: Distributed Git
172FIGURE 5-17
Initial commit
history with
featureB work.
FIGURE 5-18
Commit history after
featureA work.
Let’s say the project maintainer has pulled in a bunch of other patches and
tried your first branch, but it no longer cleanly merges. In this case, you can try
to rebase that branch on top of origin/master, resolve the conflicts for the
maintainer, and then resubmit your changes:
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
This rewrites your history to now look like Figure 5-18.
Because you rebased the branch, you have to specify the -f to your push
command in order to be able to replace the featureA branch on the server
with a commit that isn’t a descendant of it. An alternative would be to push this
new work to a different branch on the server (perhaps called featureAv2).
Let’s look at one more possible scenario: the maintainer has looked at work
in your second branch and likes the concept but would like you to change an
implementation detail. You’ll also take this opportunity to move the work to be
Contributing to a Project
173FIGURE 5-19
Commit history after
featureBv2 work.
based off the project’s current master branch. You start a new branch based off
the current origin/master branch, squash the featureB changes there, resolve any conflicts, make the implementation change, and then push that up as
a new branch:
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
The --squash option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit. This means your future commit will have one parent only and allows you to introduce all the changes from
another branch and then make more changes before recording the new commit. Also the --no-commit option can be useful to delay the merge commit in
case of the default merge process.
Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your featureBv2 branch.
Public Project over Email
Many projects have established procedures for accepting patches – you’ll need
to check the specific rules for each project, because they will differ. Since there
are several older, larger projects which accept patches via a developer mailing
list, we’ll go over an example of that now.
The workflow is similar to the previous use case – you create topic branches
for each patch series you work on. The difference is how you submit them to
the project. Instead of forking the project and pushing to your own writable verCHAPTER 5: Distributed Git
174sion, you generate email versions of each commit series and email them to the
developer mailing list:
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
Now you have two commits that you want to send to the mailing list. You use
git format-patch to generate the mbox-formatted files that you can email to
the list – it turns each commit into an email message with the first line of the
commit message as the subject and the rest of the message plus the patch that
the commit introduces as the body. The nice thing about this is that applying a
patch from an email generated with format-patch preserves all the commit
information properly.
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
The format-patch command prints out the names of the patch files it creates. The -M switch tells Git to look for renames. The files end up looking like
this:
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function
Limit log functionality to the first 20
---
lib/simplegit.rb | 2 +-
1 files changed, 1 insertions(+), 1 deletions(-)
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
end
Contributing to a Project
175def log(treeish = 'master')
- command("git log #{treeish}")
+ command("git log -n 20 #{treeish}")
end
def ls_tree(treeish = 'master')
--
2.1.0
You can also edit these patch files to add more information for the email list
that you don’t want to show up in the commit message. If you add text between
the --- line and the beginning of the patch (the diff --git line), then developers can read it; but applying the patch excludes it.
To email this to a mailing list, you can either paste the file into your email
program or send it via a command-line program. Pasting the text often causes
formatting issues, especially with “smarter” clients that don’t preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help
you send properly formatted patches via IMAP, which may be easier for you.
We’ll demonstrate how to send a patch via Gmail, which happens to be the
email agent we know best; you can read detailed instructions for a number of
mail programs at the end of the aforementioned Documentation/SubmittingPatches file in the Git source code.
First, you need to set up the imap section in your ~/.gitconfig file. You
can set each value separately with a series of git config commands, or you
can add them manually, but in the end your config file should look something
like this:
[imap]
folder = "[Gmail]/Drafts"
host = imaps://imap.gmail.com
user = user@gmail.com
pass = p4ssw0rd
port = 993
sslverify = false
If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be imap:// instead of imaps://. When that is set
up, you can use git imap-send to place the patch series in the Drafts folder of
the specified IMAP server:
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
CHAPTER 5: Distributed Git
176Logging in...
sending 2 messages
100% (2/2) done
At this point, you should be able to go to your Drafts folder, change the To
field to the mailing list you’re sending the patch to, possibly CC the maintainer
or person responsible for that section, and send it off.
You can also send the patches through an SMTP server. As before, you can
set each value separately with a series of git config commands, or you can
add them manually in the sendemail section in your ~/.gitconfig file:
[sendemail]
smtpencryption = tls
smtpserver = smtp.gmail.com
smtpuser = user@gmail.com
smtpserverport = 587
After this is done, you can use git send-email to send your patches:
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
Then, Git spits out a bunch of log information looking something like this for
each patch you’re sending:
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
\line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>
Result: OK
Contributing to a Project
177Summary
This section has covered a number of common workflows for dealing with several very different types of Git projects you’re likely to encounter, and introduced a couple of new tools to help you manage this process. Next, you’ll see
how to work the other side of the coin: maintaining a Git project. You’ll learn
how to be a benevolent dictator or integration manager.
Maintaining a Project
In addition to knowing how to effectively contribute to a project, you’ll likely
need to know how to maintain one. This can consist of accepting and applying
patches generated via format-patch and emailed to you, or integrating
changes in remote branches for repositories you’ve added as remotes to your
project. Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is
clearest for other contributors and sustainable by you over the long run.
Working in Topic Branches
When you’re thinking of integrating new work, it’s generally a good idea to try it
out in a topic branch – a temporary branch specifically made to try out that
new work. This way, it’s easy to tweak a patch individually and leave it if it’s not
working until you have time to come back to it. If you create a simple branch
name based on the theme of the work you’re going to try, such as ruby_client or something similarly descriptive, you can easily remember it if you have
to abandon it for a while and come back later. The maintainer of the Git project
tends to namespace these branches as well – such as sc/ruby_client, where
sc is short for the person who contributed the work. As you’ll remember, you
can create the branch based off your master branch like this:
$ git branch sc/ruby_client master
Or, if you want to also switch to it immediately, you can use the checkout -
b option:
$ git checkout -b sc/ruby_client master
CHAPTER 5: Distributed Git
178Now you’re ready to add your contributed work into this topic branch and
determine if you want to merge it into your longer-term branches.
Applying Patches from Email
If you receive a patch over email that you need to integrate into your project,
you need to apply the patch in your topic branch to evaluate it. There are two
ways to apply an emailed patch: with git apply or with git am.
APPLYING A PATCH WITH APPLY
If you received the patch from someone who generated it with the git diff or
a Unix diff command (which is not recommended; see the next section), you
can apply it with the git apply command. Assuming you saved the patch
at /tmp/patch-ruby-client.patch, you can apply the patch like this:
$ git apply /tmp/patch-ruby-client.patch
This modifies the files in your working directory. It’s almost identical to running a patch -p1 command to apply the patch, although it’s more paranoid
and accepts fewer fuzzy matches than patch. It also handles file adds, deletes,
and renames if they’re described in the git diff format, which patch won’t
do. Finally, git apply is an “apply all or abort all” model where either everything is applied or nothing is, whereas patch can partially apply patchfiles,
leaving your working directory in a weird state. git apply is overall much
more conservative than patch. It won’t create a commit for you – after running
it, you must stage and commit the changes introduced manually.
You can also use git apply to see if a patch applies cleanly before you try actually applying it – you can run git apply --check with the patch:
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
If there is no output, then the patch should apply cleanly. This command also exits with a non-zero status if the check fails, so you can use it in scripts if
you want.
Maintaining a Project
179APPLYING A PATCH WITH AM
If the contributor is a Git user and was good enough to use the format-patch
command to generate their patch, then your job is easier because the patch
contains author information and a commit message for you. If you can, encourage your contributors to use format-patch instead of diff to generate patches for you. You should only have to use git apply for legacy patches and
things like that.
To apply a patch generated by format-patch, you use git am. Technically,
git am is built to read an mbox file, which is a simple, plain-text format for
storing one or more email messages in one text file. It looks something like this:
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function
Limit log functionality to the first 20
This is the beginning of the output of the format-patch command that you
saw in the previous section. This is also a valid mbox email format. If someone
has emailed you the patch properly using git send-email, and you download
that into an mbox format, then you can point git am to that mbox file, and it
will start applying all the patches it sees. If you run a mail client that can save
several emails out in mbox format, you can save entire patch series into a file
and then use git am to apply them one at a time.
However, if someone uploaded a patch file generated via format-patch to
a ticketing system or something similar, you can save the file locally and then
pass that file saved on your disk to git am to apply it:
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
You can see that it applied cleanly and automatically created the new commit for you. The author information is taken from the email’s From and Date
headers, and the message of the commit is taken from the Subject and body
(before the patch) of the email. For example, if this patch was applied from the
mbox example above, the commit generated would look something like this:
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
CHAPTER 5: Distributed Git
180Author: Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit: Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700
add limit to log function
Limit log functionality to the first 20
The Commit information indicates the person who applied the patch and the
time it was applied. The Author information is the individual who originally
created the patch and when it was originally created.
But it’s possible that the patch won’t apply cleanly. Perhaps your main
branch has diverged too far from the branch the patch was built from, or the
patch depends on another patch you haven’t applied yet. In that case, the git
am process will fail and ask you what you want to do:
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
This command puts conflict markers in any files it has issues with, much like
a conflicted merge or rebase operation. You solve this issue much the same way
– edit the file to resolve the conflict, stage the new file, and then run git am --
resolved to continue to the next patch:
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
If you want Git to try a bit more intelligently to resolve the conflict, you can
pass a -3 option to it, which makes Git attempt a three-way merge. This option
isn’t on by default because it doesn’t work if the commit the patch says it was
based on isn’t in your repository. If you do have that commit – if the patch was
based on a public commit – then the -3 option is generally much smarter about
applying a conflicting patch:
Maintaining a Project
181$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
In this case, this patch had already been applied. Without the -3 option, it
looks like a conflict.
If you’re applying a number of patches from an mbox, you can also run the
am command in interactive mode, which stops at each patch it finds and asks if
you want to apply it:
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
This is nice if you have a number of patches saved, because you can view the
patch first if you don’t remember what it is, or not apply the patch if you’ve already done so.
When all the patches for your topic are applied and committed into your
branch, you can choose whether and how to integrate them into a longerrunning branch.
Checking Out Remote Branches
If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and
the name of the remote branch the changes are in, you can add them as a remote and do merges locally.
For instance, if Jessica sends you an email saying that she has a great new
feature in the ruby-client branch of her repository, you can test it by adding
the remote and checking out that branch locally:
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
CHAPTER 5: Distributed Git
182If she emails you again later with another branch containing another great
feature, you can fetch and check out because you already have the remote setup.
This is most useful if you’re working with a person consistently. If someone
only has a single patch to contribute once in a while, then accepting it over
email may be less time consuming than requiring everyone to run their own
server and having to continually add and remove remotes to get a few patches.
You’re also unlikely to want to have hundreds of remotes, each for someone
who contributes only a patch or two. However, scripts and hosted services may
make this easier – it depends largely on how you develop and how your contributors develop.
The other advantage of this approach is that you get the history of the commits as well. Although you may have legitimate merge issues, you know where
in your history their work is based; a proper three-way merge is the default
rather than having to supply a -3 and hope the patch was generated off a public commit to which you have access.
If you aren’t working with a person consistently but still want to pull from
them in this way, you can provide the URL of the remote repository to the git
pull command. This does a one-time pull and doesn’t save the URL as a remote reference:
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
* branch HEAD -> FETCH_HEAD
Merge made by recursive.
Determining What Is Introduced
Now you have a topic branch that contains contributed work. At this point, you
can determine what you’d like to do with it. This section revisits a couple of
commands so you can see how you can use them to review exactly what you’ll
be introducing if you merge this into your main branch.
It’s often helpful to get a review of all the commits that are in this branch but
that aren’t in your master branch. You can exclude commits in the master
branch by adding the --not option before the branch name. This does the
same thing as the master..contrib format that we used earlier. For example,
if your contributor sends you two patches and you create a branch called contrib and applied those patches there, you can run this:
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Maintaining a Project
183Author: Scott Chacon <schacon@gmail.com>
Date: Fri Oct 24 09:53:59 2008 -0700
seeing if this helps the gem
commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date: Mon Oct 22 19:38:36 2008 -0700
updated the gemspec to hopefully work better
To see what changes each commit introduces, remember that you can pass
the -p option to git log and it will append the diff introduced to each commit.
To see a full diff of what would happen if you were to merge this topic
branch with another branch, you may have to use a weird trick to get the correct results. You may think to run this:
$ git diff master
This command gives you a diff, but it may be misleading. If your master
branch has moved forward since you created the topic branch from it, then
you’ll get seemingly strange results. This happens because Git directly compares the snapshots of the last commit of the topic branch you’re on and the
snapshot of the last commit on the master branch. For example, if you’ve added a line in a file on the master branch, a direct comparison of the snapshots
will look like the topic branch is going to remove that line.
If master is a direct ancestor of your topic branch, this isn’t a problem; but if
the two histories have diverged, the diff will look like you’re adding all the new
stuff in your topic branch and removing everything unique to the master
branch.
What you really want to see are the changes added to the topic branch – the
work you’ll introduce if you merge this branch with master. You do that by having Git compare the last commit on your topic branch with the first common
ancestor it has with the master branch.
Technically, you can do that by explicitly figuring out the common ancestor
and then running your diff on it:
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
CHAPTER 5: Distributed Git
184FIGURE 5-20
History with several
topic branches.
However, that isn’t convenient, so Git provides another shorthand for doing
the same thing: the triple-dot syntax. In the context of the diff command, you
can put three periods after another branch to do a diff between the last commit of the branch you’re on and its common ancestor with another branch:
$ git diff master...contrib
This command shows you only the work your current topic branch has introduced since its common ancestor with master. That is a very useful syntax to
remember.
Integrating Contributed Work
When all the work in your topic branch is ready to be integrated into a more
mainline branch, the question is how to do it. Furthermore, what overall workflow do you want to use to maintain your project? You have a number of
choices, so we’ll cover a few of them.
MERGING WORKFLOWS
One simple workflow merges your work into your master branch. In this scenario, you have a master branch that contains basically stable code. When you
have work in a topic branch that you’ve done or that someone has contributed
and you’ve verified, you merge it into your master branch, delete the topic
branch, and then continue the process. If we have a repository with work in two
branches named ruby_client and php_client that looks like Figure 5-20
and merge ruby_client first and then php_client next, then your history
will end up looking like Figure 5-21.
Maintaining a Project
185FIGURE 5-21
After a topic branch
merge.
FIGURE 5-22
Before a topic
branch merge.
That is probably the simplest workflow, but it can possibly be problematic if
you’re dealing with larger or more stable projects where you want to be really
careful about what you introduce.
If you have a more important project, you might want to use a two-phase
merge cycle. In this scenario, you have two long-running branches, master and
develop, in which you determine that master is updated only when a very stable release is cut and all new code is integrated into the develop branch. You
regularly push both of these branches to the public repository. Each time you
have a new topic branch to merge in (Figure 5-22), you merge it into develop
(Figure 5-23); then, when you tag a release, you fast-forward master to wherever the now-stable develop branch is (Figure 5-24).
CHAPTER 5: Distributed Git
186FIGURE 5-23
After a topic branch
merge.
FIGURE 5-24
After a project
release.
This way, when people clone your project’s repository, they can either check
out master to build the latest stable version and keep up to date on that easily,
or they can check out develop, which is the more cutting-edge stuff. You can
also continue this concept, having an integrate branch where all the work is
merged together. Then, when the codebase on that branch is stable and passes
tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.
LARGE-MERGING WORKFLOWS
The Git project has four long-running branches: master, next, and pu (proposed updates) for new work, and maint for maintenance backports. When
new work is introduced by contributors, it’s collected into topic branches in the
maintainer’s repository in a manner similar to what we’ve described (see
Figure 5-25). At this point, the topics are evaluated to determine whether
they’re safe and ready for consumption or whether they need more work. If
they’re safe, they’re merged into next, and that branch is pushed up so everyone can try the topics integrated together.
Maintaining a Project
187FIGURE 5-25
Managing a complex
series of parallel
contributed topic
branches.
FIGURE 5-26
Merging contributed
topic branches into
long-term
integration
branches.
If the topics still need work, they’re merged into pu instead. When it’s determined that they’re totally stable, the topics are re-merged into master and are
then rebuilt from the topics that were in next but didn’t yet graduate to master. This means master almost always moves forward, next is rebased occasionally, and pu is rebased even more often:
CHAPTER 5: Distributed Git
188FIGURE 5-27
Example history
before a cherry-pick.
When a topic branch has finally been merged into master, it’s removed from
the repository. The Git project also has a maint branch that is forked off from
the last release to provide backported patches in case a maintenance release is
required. Thus, when you clone the Git repository, you have four branches that
you can check out to evaluate the project in different stages of development,
depending on how cutting edge you want to be or how you want to contribute;
and the maintainer has a structured workflow to help them vet new contributions.
REBASING AND CHERRY PICKING WORKFLOWS
Other maintainers prefer to rebase or cherry-pick contributed work on top of
their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to
integrate it, you move to that branch and run the rebase command to rebuild
the changes on top of your current master (or develop, and so on) branch. If
that works well, you can fast-forward your master branch, and you’ll end up
with a linear project history.
The other way to move introduced work from one branch to another is to
cherry-pick it. A cherry-pick in Git is like a rebase for a single commit. It takes
the patch that was introduced in a commit and tries to reapply it on the branch
you’re currently on. This is useful if you have a number of commits on a topic
branch and you want to integrate only one of them, or if you only have one
commit on a topic branch and you’d prefer to cherry-pick it rather than run rebase. For example, suppose you have a project that looks like this:
If you want to pull commit e43a6 into your master branch, you can run
Maintaining a Project
189FIGURE 5-28
History after cherrypicking a commit on
a topic branch.
$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
3 files changed, 17 insertions(+), 3 deletions(-)
This pulls the same change introduced in e43a6, but you get a new commit
SHA-1 value, because the date applied is different. Now your history looks like
this:
Now you can remove your topic branch and drop the commits you didn’t
want to pull in.
RERERE
If you’re doing lots of merging and rebasing, or you’re maintaining a long-lived
topic branch, Git has a feature called “rerere” that can help.
Rerere stands for “reuse recorded resolution” – it’s a way of shortcutting
manual conflict resolution. When rerere is enabled, Git will keep a set of preand post-images from successful merges, and if it notices that there’s a conflict
that looks exactly like one you’ve already fixed, it’ll just use the fix from last
time, without bothering you with it.
This feature comes in two parts: a configuration setting and a command. The
configuration setting is rerere.enabled, and it’s handy enough to put in your
global config:
CHAPTER 5: Distributed Git
190$ git config --global rerere.enabled true
Now, whenever you do a merge that resolves conflicts, the resolution will be
recorded in the cache in case you need it in the future.
If you need to, you can interact with the rerere cache using the git rerere
command. When it’s invoked alone, Git checks its database of resolutions and
tries to find a match with any current merge conflicts and resolve them (although this is done automatically if rerere.enabled is set to true). There are
also subcommands to see what will be recorded, to erase specific resolution
from the cache, and to clear the entire cache. We will cover rerere in more detail
in “Rerere”.
Tagging Your Releases
When you’ve decided to cut a release, you’ll probably want to drop a tag so you
can re-create that release at any point going forward. You can create a new tag
as discussed in Chapter 2. If you decide to sign the tag as the maintainer, the
tagging may look something like this:
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
If you do sign your tags, you may have the problem of distributing the public
PGP key used to sign your tags. The maintainer of the Git project has solved this
issue by including their public key as a blob in the repository and then adding a
tag that points directly to that content. To do this, you can figure out which key
you want by running gpg --list-keys:
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub 1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid Scott Chacon <schacon@gmail.com>
sub 2048g/45D02282 2009-02-09 [expires: 2010-02-09]
Then, you can directly import the key into the Git database by exporting it
and piping that through git hash-object, which writes a new blob with
those contents into Git and gives you back the SHA-1 of the blob:
Maintaining a Project
191$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
Now that you have the contents of your key in Git, you can create a tag that
points directly to it by specifying the new SHA-1 value that the hash-object
command gave you:
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
If you run git push --tags, the maintainer-pgp-pub tag will be shared
with everyone. If anyone wants to verify a tag, they can directly import your
PGP key by pulling the blob directly out of the database and importing it into
GPG:
$ git show maintainer-pgp-pub | gpg --import
They can use that key to verify all your signed tags. Also, if you include instructions in the tag message, running git show <tag> will let you give the
end user more specific instructions about tag verification.
Generating a Build Number
Because Git doesn’t have monotonically increasing numbers like v123 or the
equivalent to go with each commit, if you want to have a human-readable
name to go with a commit, you can run git describe on that commit. Git
gives you the name of the nearest tag with the number of commits on top of
that tag and a partial SHA-1 value of the commit you’re describing:
$ git describe master
v1.6.2-rc1-20-g8c5b85c
This way, you can export a snapshot or build and name it something understandable to people. In fact, if you build Git from source code cloned from the
Git repository, git --version gives you something that looks like this. If
you’re describing a commit that you have directly tagged, it gives you the tag
name.
The git describe command favors annotated tags (tags created with the
-a or -s flag), so release tags should be created this way if you’re using git
CHAPTER 5: Distributed Git
192describe, to ensure the commit is named properly when described. You can
also use this string as the target of a checkout or show command, although it
relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure
SHA-1 object uniqueness, so older git describe output names were invalidated.
Preparing a Release
Now you want to release a build. One of the things you’ll want to do is create an
archive of the latest snapshot of your code for those poor souls who don’t use
Git. The command to do this is git archive:
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
If someone opens that tarball, they get the latest snapshot of your project
under a project directory. You can also create a zip archive in much the same
way, but by passing the --format=zip option to git archive:
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
You now have a nice tarball and a zip archive of your project release that you
can upload to your website or email to people.
The Shortlog
It’s time to email your mailing list of people who want to know what’s happening in your project. A nice way of quickly getting a sort of changelog of what has
been added to your project since your last release or email is to use the git
shortlog command. It summarizes all the commits in the range you give it; for
example, the following gives you a summary of all the commits since your last
release, if your last release was named v1.0.1:
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
Add support for annotated tags to Grit::Tag
Add packed-refs annotated tag support.
Add Grit::Commit#to_patch
Maintaining a Project
193Update version and History.txt
Remove stray `puts`
Make ls_tree ignore nils
Tom Preston-Werner (4):
fix dates in history
dynamic version method
Version bump to 1.0.2
Regenerated gemspec for version 1.0.2
You get a clean summary of all the commits since v1.0.1, grouped by author,
that you can email to your list.
Summary
You should feel fairly comfortable contributing to a project in Git as well as
maintaining your own project or integrating other users’ contributions. Congratulations on being an effective Git developer! In the next chapter, you’ll learn
about how to use the largest and most popular Git hosting service, GitHub.
CHAPTER 5: Distributed Git
194GitHub
GitHub is the single largest host for Git repositories, and is the central point of
collaboration for millions of developers and projects. A large percentage of all
Git repositories are hosted on GitHub, and many open-source projects use it for
Git hosting, issue tracking, code review, and other things. So while it’s not a direct part of the Git open source project, there’s a good chance that you’ll want
or need to interact with GitHub at some point while using Git professionally.
This chapter is about using GitHub effectively. We’ll cover signing up for and
managing an account, creating and using Git repositories, common workflows
to contribute to projects and to accept contributions to yours, GitHub’s programmatic interface and lots of little tips to make your life easier in general.
If you are not interested in using GitHub to host your own projects or to collaborate with other projects that are hosted on GitHub, you can safely skip to
Chapter 7.
INTERFACES CHANGE
It’s important to note that like many active websites, the UI elements in
these screenshots are bound to change over time. Hopefully the general
idea of what we’re trying to accomplish here will still be there, but if you
want more up to date versions of these screens, the online versions of
this book may have newer screenshots.
Account Setup and Configuration
The first thing you need to do is set up a free user account. Simply visit https://
github.com, choose a user name that isn’t already taken, provide an email address and a password, and click the big green “Sign up for GitHub” button.
195
6FIGURE 6-1
The GitHub sign-up
form.
The next thing you’ll see is the pricing page for upgraded plans, but it’s safe
to ignore this for now. GitHub will send you an email to verify the address you
provided. Go ahead and do this, it’s pretty important (as we’ll see later).
GitHub provides all of its functionality with free accounts, with the limitation that all of your projects are fully public (everyone has read access).
GitHub’s paid plans include a set number of private projects, but we
won’t be covering those in this book.
Clicking the Octocat logo at the top-left of the screen will take you to your
dashboard page. You’re now ready to use GitHub.
SSH Access
As of right now, you’re fully able to connect with Git repositories using the
https:// protocol, authenticating with the username and password you just
set up. However, to simply clone public projects, you don’t even need to sign up
- the account we just created comes into play when we fork projects and push
to our forks a bit later.
CHAPTER 6: GitHub
196FIGURE 6-2
The “Account
settings” link.
FIGURE 6-3
The “SSH keys” link.
If you’d like to use SSH remotes, you’ll need to configure a public key. (If you
don’t already have one, see “Generating Your SSH Public Key”.) Open up your
account settings using the link at the top-right of the window:
Then select the “SSH keys” section along the left-hand side.
From there, click the "Add an SSH key" button, give your key a name,
paste the contents of your ~/.ssh/id_rsa.pub (or whatever you named it)
public-key file into the text area, and click “Add key”.
Be sure to name your SSH key something you can remember. You can
name each of your keys (e.g. “My Laptop” or “Work Account”) so that if
you need to revoke a key later, you can easily tell which one you’re looking for.
Account Setup and Configuration
197FIGURE 6-4
The “Profile” link.
Your Avatar
Next, if you wish, you can replace the avatar that is generated for you with an
image of your choosing. First go to the “Profile” tab (above the SSH Keys tab)
and click “Upload new picture”.
We’ll choose a copy of the Git logo that is on our hard drive and then we get
a chance to crop it.
CHAPTER 6: GitHub
198FIGURE 6-5
Crop your avatar
Now anywhere you interact on the site, people will see your avatar next to
your username.
If you happen to have uploaded an avatar to the popular Gravatar service
(often used for Wordpress accounts), that avatar will be used by default and you
don’t need to do this step.
Your Email Addresses
The way that GitHub maps your Git commits to your user is by email address. If
you use multiple email addresses in your commits and you want GitHub to link
them up properly, you need to add all the email addresses you have used to the
Emails section of the admin section.
Account Setup and Configuration
199FIGURE 6-6
Add email addresses
In Figure 6-6 we can see some of the different states that are possible. The
top address is verified and set as the primary address, meaning that is where
you’ll get any notifications and receipts. The second address is verified and so
can be set as the primary if you wish to switch them. The final address is unverified, meaning that you can’t make it your primary address. If GitHub sees any of
these in commit messages in any repository on the site, it will be linked to your
user now.
Two Factor Authentication
Finally, for extra security, you should definitely set up Two-factor Authentication or “2FA”. Two-factor Authentication is an authentication mechanism that is
becoming more and more popular recently to mitigate the risk of your account
being compromised if your password is stolen somehow. Turning it on will
make GitHub ask you for two different methods of authentication, so that if one
of them is compromised, an attacker will not be able to access your account.
You can find the Two-factor Authentication setup under the Security tab of
your Account settings.
CHAPTER 6: GitHub
200FIGURE 6-7
2FA in the Security
Tab
If you click on the “Set up two-factor authentication” button, it will take you
to a configuration page where you can choose to use a phone app to generate
your secondary code (a “time based one-time password”), or you can have GitHub send you a code via SMS each time you need to log in.
After you choose which method you prefer and follow the instructions for
setting up 2FA, your account will then be a little more secure and you will have
to provide a code in addition to your password whenever you log into GitHub.
Contributing to a Project
Now that our account is set up, let’s walk through some details that could be
useful in helping you contribute to an existing project.
Forking Projects
If you want to contribute to an existing project to which you don’t have push
access, you can “fork” the project. What this means is that GitHub will make a
copy of the project that is entirely yours; it lives in your user’s namespace, and
you can push to it.
Contributing to a Project
201FIGURE 6-8
The “Fork” button.
Historically, the term “fork” has been somewhat negative in context,
meaning that someone took an open source project in a different direction, sometimes creating a competing project and splitting the contributors. In GitHub, a “fork” is simply the same project in your own namespace, allowing you to make changes to a project publicly as a way to
contribute in a more open manner.
This way, projects don’t have to worry about adding users as collaborators
to give them push access. People can fork a project, push to it, and contribute
their changes back to the original repository by creating what’s called a Pull Request, which we’ll cover next. This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the
change until the owner is happy with it, at which point the owner can merge it
in.
To fork a project, visit the project page and click the “Fork” button at the
top-right of the page.
After a few seconds, you’ll be taken to your new project page, with your own
writeable copy of the code.
The GitHub Flow
GitHub is designed around a particular collaboration workflow, centered on
Pull Requests. This flow works whether you’re collaborating with a tightly-knit
team in a single shared repository, or a globally-distributed company or network of strangers contributing to a project through dozens of forks. It is centered on the “Topic Branches” workflow covered in Chapter 3.
Here’s how it generally works:
1. Create a topic branch from master.
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.
CHAPTER 6: GitHub
202FIGURE 6-9
The project we want
to contribute to.
This is basically the Integration Manager workflow covered in “IntegrationManager Workflow”, but instead of using email to communicate and review
changes, teams use GitHub’s web based tools.
Let’s walk through an example of proposing a change to an open source
project hosted on GitHub using this flow.
CREATING A PULL REQUEST
Tony is looking for code to run on his Arduino programmable microcontroller
and has found a great program file on GitHub at https://github.com/schacon/
blink.
The only problem is that the blinking rate is too fast, we think it’s much nicer
to wait 3 seconds instead of 1 in between each state change. So let’s improve
the program and submit it back to the project as a proposed change.
First, we click the Fork button as mentioned earlier to get our own copy of
the project. Our user name here is “tonychacon” so our copy of this project is at
https://github.com/tonychacon/blink and that’s where we can edit it.
We will clone it locally, create a topic branch, make the code change and finally
push that change back up to GitHub.
Contributing to a Project
203$ git clone https://github.com/tonychacon/blink
Cloning into 'blink'...
$ cd blink
$ git checkout -b slow-blink
Switched to a new branch 'slow-blink'
$ sed -i '' 's/1000/3000/' blink.ino
$ git diff --word-diff
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
digitalWrite(led, HIGH); // turn the LED on (HIGH is the voltage level)
[-delay(1000);-]{+delay(3000);+} // wait for a second
digitalWrite(led, LOW); // turn the LED off by making the voltage LOW
[-delay(1000);-]{+delay(3000);+} // wait for a second
} $
git commit -a -m 'three seconds is better'
[slow-blink 5ca509d] three seconds is better
1 file changed, 2 insertions(+), 2 deletions(-)
$ git push origin slow-blink
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
* [new branch] slow-blink -> slow-blink
Clone our fork of the project locally
Create a descriptive topic branch
Make our change to the code
Check that the change is good
Commit our change to the topic branch
CHAPTER 6: GitHub
204FIGURE 6-10
Pull Request button
Push our new topic branch back up to our GitHub fork
Now if we go back to our fork on GitHub, we can see that GitHub noticed that
we pushed a new topic branch up and present us with a big green button to
check out our changes and open a Pull Request to the original project.
You can alternatively go to the “Branches” page at https://github.com/
<user>/<project>/branches to locate your branch and open a new Pull Request from there.
If we click that green button, we’ll see a screen that asks us to give our Pull
Request a title and description. It is almost always worthwhile to put some efffortinto this, since a good description helps the owner of the original project
determine what you were trying to do, whether your proposed changes are correct, and whether accepting the changes would improve the original project.
We also see a list of the commits in our topic branch that are “ahead” of the
master branch (in this case, just the one) and a unified diff of all the changes
that will be made should this branch get merged by the project owner.
Contributing to a Project
205FIGURE 6-11
Pull Request
creation page
When you hit the Create pull request button on this screen, the owner of the
project you forked will get a notification that someone is suggesting a change
and will link to a page that has all of this information on it.
Though Pull Requests are used commonly for public projects like this
when the contributor has a complete change ready to be made, it’s also
often used in internal projects at the beginning of the development cycle.
Since you can keep pushing to the topic branch even after the Pull Request is opened, it’s often opened early and used as a way to iterate on
work as a team within a context, rather than opened at the very end of
the process.
ITERATING ON A PULL REQUEST
At this point, the project owner can look at the suggested change and merge it,
reject it or comment on it. Let’s say that he likes the idea, but would prefer a
slightly longer time for the light to be off than on.
CHAPTER 6: GitHub
206FIGURE 6-12
Comment on a
specific line of code
in a Pull Request
FIGURE 6-13
Comments sent as
email notifications
Where this conversation may take place over email in the workflows presented in Chapter 5, on GitHub this happens online. The project owner can review
the unified diff and leave a comment by clicking on any of the lines.
Once the maintainer makes this comment, the person who opened the Pull
Request (and indeed, anyone else watching the repository) will get a notification. We’ll go over customizing this later, but if he had email notifications
turned on, Tony would get an email like this:
Anyone can also leave general comments on the Pull Request. In Figure 6-14
we can see an example of the project owner both commenting on a line of code
Contributing to a Project
207FIGURE 6-14
Pull Request
discussion page
and then leaving a general comment in the discussion section. You can see that
the code comments are brought into the conversation as well.
Now the contributor can see what they need to do in order to get their
change accepted. Luckily this is very straightforward. Where over email you
may have to re-roll your series and resubmit it to the mailing list, with GitHub
you simply commit to the topic branch again and push, which will automatically update the Pull Request. In Figure 6-15 you can also see that the old code
comment has been collapsed in the updated Pull Request, since it was made on
a line that has since been changed.
Adding commits to an existing Pull Request doesn’t trigger a notification, so
once Tony has pushed his corrections he decides to leave a comment to inform
the project owner that he made the requested change.
CHAPTER 6: GitHub
208FIGURE 6-15
Pull Request final
An interesting thing to notice is that if you click on the “Files Changed” tab
on this Pull Request, you’ll get the “unified” diff — that is, the total aggregate
difference that would be introduced to your main branch if this topic branch
was merged in. In git diff terms, it basically automatically shows you git
diff master...<branch> for the branch this Pull Request is based on. See
“Determining What Is Introduced” for more about this type of diff.
The other thing you’ll notice is that GitHub checks to see if the Pull Request
merges cleanly and provides a button to do the merge for you on the server.
This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a “non-fast-forward”
merge, meaning that even if the merge could be a fast-forward, it will still create a merge commit.
Contributing to a Project
209If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the master branch and push it to GitHub, the
Pull Request will automatically be closed.
This is the basic workflow that most GitHub projects use. Topic branches are
created, Pull Requests are opened on them, a discussion ensues, possibly more
work is done on the branch and eventually the request is either closed or
merged.
NOT ONLY FORKS
It’s important to note that you can also open a Pull Request between two
branches in the same repository. If you’re working on a feature with
someone and you both have write access to the project, you can push a
topic branch to the repository and open a Pull Request on it to the master
branch of that same project to initiate the code review and discussion
process. No forking necessary.
Advanced Pull Requests
Now that we’ve covered the basics of contributing to a project on GitHub, let’s
cover a few interesting tips and tricks about Pull Requests so you can be more
effective in using them.
PULL REQUESTS AS PATCHES
It’s important to understand that many projects don’t really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most
mailing list-based projects think of patch series contributions. Most GitHub
projects think about Pull Request branches as iterative conversations around a
proposed change, culminating in a unified diff that is applied by merging.
This is an important distinction, because generally the change is suggested
before the code is thought to be perfect, which is far more rare with mailing list
based patch series contributions. This enables an earlier conversation with the
maintainers so that arriving at the proper solution is more of a community efffort.When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead
the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.
For instance, if you go back and look again at Figure 6-15, you’ll notice that
the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This
way if you go back and look at this Pull Request in the future, you can easily find
all of the context of why decisions were made. Pushing the “Merge” button on
CHAPTER 6: GitHub
210FIGURE 6-16
Pull Request does
not merge cleanly
the site purposefully creates a merge commit that references the Pull Request
so that it’s easy to go back and research the original conversation if necessary.
KEEPING UP WITH UPSTREAM
If your Pull Request becomes out of date or otherwise doesn’t merge cleanly,
you will want to fix it so the maintainer can easily merge it. GitHub will test this
for you and let you know at the bottom of every Pull Request if the merge is
trivial or not.
If you see something like Figure 6-16, you’ll want to fix your branch so that it
turns green and the maintainer doesn’t have to do extra work.
You have two main options in order to do this. You can either rebase your
branch on top of whatever the target branch is (normally the master branch of
the repository you forked), or you can merge the target branch into your
branch.
Most developers on GitHub will choose to do the latter, for the same reasons
we just went over in the previous section. What matters is the history and the
final merge, so rebasing isn’t getting you much other than a slightly cleaner history and in return is far more difficult and error prone.
If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge
the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.
For example, let’s say that in the “tonychacon” example we were using before, the original author made a change that would create a conflict in the Pull
Request. Let’s go through those steps.
$ git remote add upstream https://github.com/schacon/blink
$ git fetch upstream
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
Contributing to a Project
211* [new branch] master -> upstream/master
$ git merge upstream/master
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.
$ vim blink.ino
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
into slower-blink
$ git push origin slow-blink
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
ef4725c..3c8d735 slower-blink -> slow-blink
Add the original repository as a remote named “upstream”
Fetch the newest work from that remote
Merge the main branch into your topic branch
Fix the conflict that occurred
Push back up to the same topic branch
Once you do that, the Pull Request will be automatically updated and rechecked to see if it merges cleanly.
CHAPTER 6: GitHub
212FIGURE 6-17
Pull Request now
merges cleanly
One of the great things about Git is that you can do that continuously. If you
have a very long-running project, you can easily merge from the target branch
over and over again and only have to deal with conflicts that have arisen since
the last time that you merged, making the process very manageable.
If you absolutely wish to rebase the branch to clean it up, you can certainly
do so, but it is highly encouraged to not force push over the branch that the Pull
Request is already opened on. If other people have pulled it down and done
more work on it, you run into all of the issues outlined in “The Perils of Rebasing”. Instead, push the rebased branch to a new branch on GitHub and open a
brand new Pull Request referencing the old one, then close the original.
REFERENCES
Your next question may be “How do I reference the old Pull Request?”. It turns
out there are many, many ways to reference other things almost anywhere you
can write in GitHub.
Let’s start with how to cross-reference another Pull Request or an Issue. All
Pull Requests and Issues are assigned numbers and they are unique within the
project. For example, you can’t have Pull Request #3 and Issue #3. If you want
to reference any Pull Request or Issue from any other one, you can simply put
#<num> in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write username#<num> if you’re referring to an Issue or Pull Request in a fork of the repository you’re in, or username/repo#<num> to reference something in another repository.
Let’s look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull
request from the new one. We also want to reference an issue in the fork of the
repository and an issue in a completely different project. We can fill out the description just like Figure 6-18.
Contributing to a Project
213FIGURE 6-18
Cross references in a
Pull Request.
FIGURE 6-19
Cross references
rendered in a Pull
Request.